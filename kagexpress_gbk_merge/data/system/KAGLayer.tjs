// KAGLayer.tjs - KAG のレイヤの基本クラス
// Copyright (C)2001-2008, W.Dee and contributors  改?配布は自由です

/*
 レイヤvBのクラスA

 Layer ( 吉里吉里ネイティヴクラス )
  |
  +-- KAGLayer ( このファイル )
       |
       +-- AnimationLayer ( AnimationLayer.tjs )
       |    |
       |    +-- ClickGlyphLayer ( AnimationLayer.tjs )
       |    |
       |    +-- GraphicLayer ( GraphicLayer.tjs )
       |         |
       |         +-- BaseLayer ( GraphicLayer.tjs )
       |         |
       |         +-- CharacterLayer ( GraphicLayer.tjs )
       |
       +-- MessageLayer ( MessageLayer.tjs )
       |
       +-- ButtonLayer ( ButtonLayer.tjs )
       |    |
       |    +-- LinkButtonLayer ( MessageLayer.tjs )
       |    |
       |    +-- LButtonLayer ( HistoryLayer.tjs )
       |
       +-- EditLayer ( EditLayer.tjs )
       |    |
       |    +-- LinkEditLayer ( MessageLayer.tjs )
       |
       +-- CheckBoxLayer ( CheckBoxLayer.tjs )
            |
            +-- LinkCheckBoxLayer ( MessageLayer.tjs )
*/

/*
　ちょっとわかりづらい、トランジションK了rの幼鳏摔膜い埔えき

　吉里吉里はトランジションK了rに、トランジション元(src=相手)がある龊悉稀
子レイヤを含む(children=true)龊悉舷嗍证去磨戛`ごと自分自身のレイヤを交Qし、
子レイヤを含まない(children=false)龊悉稀⒆婴谓~的なツリ`上の位置はその
ままにして相手と入れ替わる。

　子レイヤを含まないトランジションを行えるのは背景レイヤのみ。

トランジションを行うと、上における「入れ替え」を行うが、吉里吉里本体の
入れ替え、は name などの重要な情螭馊毪焯妞à皮筏蓼Δ韦恰
GraphicLayer.exchangeInfo で内容を交Qする。

また、trans 属性で exchange=true が指定された龊悉稀I者のレイヤは入れ替わ
るが、exchange=false (デフォルト) が指定された龊悉稀トランジション元(src)
からトランジション先への情螭违偿冤`を行わないとならない。

srcなし のrはレイヤg独でのトランジションが行われるのでこれらの考]は
必要ないが、K了rには子レイヤがすべて非表示になる。

?メッセ`ジレイヤ、前景レイヤが、srcなしでトランジション (children=true)
　何もしなくてよいが、K了後それらの子レイヤは自拥膜朔潜硎兢摔胜搿

?メッセ`ジレイヤ、前景レイヤが、srcありでトランジション (children=true)
　重要な情螭颔去楗螗弗伐绁笤と交Q、exchange=false の龊悉悉丹椁
　トランジション元の情螭颔去楗螗弗伐绁笙趣衰偿冤`。ただし、このコピ`のHに
　ウィンドウの可?不可の情螭膝偿冤`しない。

?背景レイヤがsrcなしでトランジション(children=true)
　何もしなくてよいが、K了rに子レイヤは非表示になる。

?背景レイヤがsrcなしでトランジション(children=false)
　本当に何もしない。

?背景レイヤがsrcありでトランジション(children=true)
　重要な情螭颔去楗螗弗伐绁笤と交Q、しかも子レイヤにしてもこの
　「重要な情螭蛳嗍证冉Q」の指示を出す。exchange=false の龊悉悉丹椁
　トランジション元の情螭颔去楗螗弗伐绁笙趣衰偿冤`。これも、子レイヤすべて
　にしても指示する。

?背景レイヤがsrcありでトランジション(children=false)
　重要な情螭颔去楗螗弗伐绁笤と交Q。子レイヤにしては
　「重要な情螭蛳嗍证冉Q」の指示をださない。exchange=false の龊悉
　さらにトランジション元の情螭颔去楗螗弗伐绁笙趣衰偿冤`。
　これも子レイヤにしては指示しない。

*/

class KAGLayer extends Layer
{
	// KAG で用いる背景/前景レイヤ、メッセ`ジレイヤ、ボタンレイヤなどの基本クラス
	var inTransition = false; // トランジション中か
	var transExchange = false; // トランジションK了rに入れ替えを行うか
	var transWithChildren = false; // トランジションは子レイヤも含めて行うか

	var moveObject; // F在M行中の自右佑氓ブジェクト(M行していないときはvoid)

	function KAGLayer(win, par)
	{
		super.Layer(win, par);
	}

	function finalize()
	{
		invalidate moveObject if moveObject !== void;
		super.finalize(...);
	}

	function setOptions(elm)
	{
		// elm に兢盲匹欹ぅ浃违プションをO定
		visible = +elm.visible if elm.visible !== void;
		left = +elm.left if elm.left !== void;
		top = +elm.top if elm.top !== void;
		opacity = +elm.opacity if elm.opacity !== void;

		if(elm.modal !== void)
		{
			// this would not work well
			var modal = elm.modal;
			if(modal) setMode(), focus(); else removeMode();
		}

		absolute = +elm.index if elm.index !== void;
	}

	function loadImages(storage, key)
	{
		// loadImages オ`バ`ライド
		key = adjustColorKey(key);
		return super.loadImages(storage, key);
	}

	function adjustColorKey(key)
	{
		// 文字列で与えられたカラ`キ`のQ
		if(key === void)
			key = clNone;
		else if(typeof key == "String")
		{
			if(key == "adapt")
				key = clAdapt; // adaptive color key
			else
			{
				if(key.length >= 7)
					key = +key;
				else
					key = +key + 0x3000000; // 0x3000000 = パレットインデックスによる指定
			}
		}
		return key;
	}

	function assignImages(src, copyvisiblestate = false)
	{
		// assignImages オ`バ`ライド
		// src の「目にえる」情螭颏长违欹ぅ浃衰偿冤`する
		// コピ`される内容は、
		// ?透明度
		// ?位置
		// ?表示サイズ
		// ?レイヤ内画像表示位置(imageLeft, imageTop)
		//  ( 上３つは copyvisiblestate = true のばあい )
		// ?画像サイズ
		// ?レイヤ画像、I域画像
		super.assignImages(src);
		if(copyvisiblestate)
		{
			var su = super;
			su.visible = src.visible;
			su.opacity = src.opacity;
			su.absolute = src.absolute if !src.isPrimary && src.parent.absoluteOrderMode;
			su.type = src.type;
			su.setPos(src.left, src.top, src.width, src.height);
			su.setImagePos(src.imageLeft, src.imageTop);
		}
	}

	function assignVisibleState(src)
	{
		// src から上 assignImages のうち、copyvisiblestate = true に
		// したときだけにコピ`される情螭颔偿冤`
		visible = src.visible;
		opacity = src.opacity;
		absolute = src.absolute if !src.isPrimary && src.parent.absoluteOrderMode;
		type = src.type;
		setPos(src.left, src.top, src.width, src.height);
		setImagePos(src.imageLeft, src.imageTop);
	}

	function beginTransition(elm, src)
	{
		// beginTransition オ`バ`ライド
		// elm に兢ぁトランジションを_始する
		// src にはトランジションの相手を指定
//		stopTransition(); // F在のトランジションは停止

		if(elm.exchange !== void) transExchange = +elm.exchange; else transExchange = false;
		var method = elm.method;
		if(elm.time !== void)
		{
			elm.time = 1 if +elm.time == 0; // rgに 0 は指定できないので
		}
		if(method === void)
		{
			method = 'universal'; // デフォルトでユニバ`サル
		}
		else if(method == 'scroll')
		{
			// パラメ`タのQ
			switch(elm.from)
			{
			case 'left': elm.from = sttLeft; break;
			case 'top': elm.from = sttTop; break;
			case 'right': elm.from = sttRight; break;
			case 'bottom': elm.from = sttBottom; break;
			}
			switch(elm.stay)
			{
			case 'nostay': elm.stay = ststNoStay; break;
			case 'stayback': elm.stay = ststStaySrc; break;
			case 'stayfore': elm.stay = ststStayDest; break;
			default: elm.stay = ststNoStay; break;
			}
		}
		var withchildren = elm.children;
		if(withchildren === void)
			withchildren = true;
		else
			withchildren = +withchildren;
		transWithChildren = withchildren;
		inTransition = true;
		window.transCount++; // M行中のトランジションの数をやす
		super.beginTransition(method, withchildren, src, elm);
	}

	function onTransitionCompleted(dest, src)
	{
		super.onTransitionCompleted(...);
		if(window != null)
		{
			inTransition = false;
			window.transCount--; // M行中のトランジションの数をpらす
			atEndOfTransition(src, transWithChildren, transExchange);
			window.onLayerTransitionCompleted(this, dest, src);
		}
	}

	function atEndOfTransition(src, withchildren, exchange)
	{
		// 必要に辘袱 オ`バ`ライドすること
		// トランジションがK了したときに呼ばれる。
		// レイヤg独でトランジションが行われた龊悉 src は null になる。
		// そうでない龊稀exchange が true のrは、src と 自分の内容
		// を取り替え、そうでなければ src に自分の内容
		// をコピ`。
		// 子レイヤも含めてトランジションが行われた龊悉 withchildren が
		// true になる。
		// root は、トランジションの大本にして呼ばれるときに true になる。
	}

	function beginMove(elm)
	{
		// elm に兢ぷ右婴蜷_始する
		stopMove();

		// path の分解
		var array = [].split("(), ", elm.path, , true);
		for(var i = array.count-1; i>=0; i--) array[i+3] = +array[i];
		array[0] = left;
		array[1] = top;
		array[2] = opacity;

		// 移佑氓ブジェクトの作成
		if(elm.spline !== void && +elm.spline)
		{
			// スプラインag
			moveObject = new SplineMover(this, array, +elm.time,
				elm.accel === void ? 0 : +elm.accel, moveFinalFunction);
		}
		else
		{
			// 直ag
			moveObject = new LinearMover(this, array, +elm.time,
				elm.accel === void ? 0 : +elm.accel, moveFinalFunction);
		}
		window.moveCount++;
		moveObject.startMove(+elm.delay);
	}

	function moveFinalFunction()
	{
		// 自右婴K了するときに呼ばれるv数
		window.moveCount--;
		window.onLayerMoveStop();
	}

	function stopMove()
	{
		if(moveObject !== void) invalidate moveObject, moveObject = void;
	}

	// フレ`ム番号を指定したmove
	function beginFrameMove(elm)
	{
		// elm に兢ぷ右婴蜷_始する
		stopMove();

		var ox = elm.ox === void ? 0 : +elm.ox;
		var oy = elm.oy === void ? 0 : +elm.oy;
		var fps = elm.fps === void ? 30 : +elm.fps;

		// path の分解
		var array = [].split("(), ", elm.path, , true);
		for(var i = array.count-1; i>=0; i--) array[i+4] = +array[i];
		array[0] = 0;
		array[1] = left - ox;
		array[2] = top - oy;
		array[3] = opacity;

		// 移佑氓ブジェクトの作成
		moveObject = new LinearFrameMover(this, array, fps, moveFinalFunction, ox, oy );

		window.moveCount++;
		moveObject.startMove();
	}

	function store()
	{
		// 辞配列にF在の状Bを保存する
		var dic = %[];
		dic.left = left;
		dic.top = top;
		dic.width = width;
		dic.height = height;
		dic.imageWidth = imageWidth;
		dic.imageHeight = imageHeight;
		dic.opacity = opacity;
		dic.visible = visible;
		dic.imageLeft = imageLeft;
		dic.imageTop = imageTop;
		dic.absolute = absolute;
		dic.type = type;
		return dic;
	}

	function restore(dic)
	{
		// 辞配列 dic から情螭蛘iみ出し、このレイヤにO定する
		setImageSize(dic.imageWidth, dic.imageHeight);
		setPos(dic.left, dic.top, dic.width, dic.height);
		setImagePos(dic.imageLeft, dic.imageTop);
		opacity = dic.opacity;
		visible = dic.visible;
		absolute = dic.absolute if !isPrimary && dic.absolute !== void;
		type = dic.type if !isPrimary && dic.type !== void;
	}

	/**
	 * レイヤへの色反映I理
	 * @param left
	 * @param top
	 * @param width
	 * @param height
	 * @param color Tりつぶす色(マスクを含む）
	 * @param mode 合成モ`ド
	 */
	function fillOperateRect(left, top, width, height, color, mode)
	{
		var tw = 128;
		var th = 64;
		var fillLayer = new global.Layer(window, this);
		// 元々吉里吉里のものなら、不透明の一色レイヤ`を、不透明度を指定して描画。
		// PhotoShopのものなら、半透明の一色レイヤ`を、透明度を指定せず(opacity=255)に描画。
		var orgmodes	= %[ltOpaque=>1,ltAlpha=>1,ltAddAlpha=>1,ltAdditive=>1,ltSubtractive=>1,ltMultiplicative=>1,ltDodge=>1,ltLighten=>1,ltDarken=>1,ltScreen=>1];
		fillLayer.setSize(tw, th);
		var opacity	= 255;
		var lastface = face, lastha = holdAlpha;
		if(orgmodes[mode])
		{
			fillLayer.fillRect(0, 0, tw, th, color | 0xFF000000);
			opacity = (color >> 24) & 0xFF;
			face	= dfOpaque;
		}
		else
			fillLayer.fillRect(0, 0, tw, th, color);
		holdAlpha	= true if !isPrimary;
		var x = 0;
		var y = 0;
		while (y < height) {
			var x2 = x;
			while (x2 < width) {
				//Debug.message("pos:" + x2 + "," + y);
				global.Layer.operateRect(x2, y, fillLayer, 0, 0, tw, th, mode, opacity);
				x2 += tw;
			}
			y += th;
		}
		face = lastface, holdAlpha = lastha;
		// 後片付け
		invalidate fillLayer;
	}

	/**
	 * 影を追加する
	 * @param dx 影のX移恿 (右にプラス)
	 * @param dy 影のY移恿 (下にプラス)
	 * @param blur ぼかし量
	 * @param shadowColor 影の色
	 * @param shadoAlpha 影の不透明度
	 */
	function doDropShadow(dx=10, dy=10, blur=3, shadowColor=0x000000, shadowOpacity=200)
	{
		var THIS = global.Layer;
		
		// 作I用レイヤ
		var work = new THIS(window, parent);
		work.setImagePos(THIS.imageLeft, THIS.imageTop);
		work.setImageSize(THIS.imageWidth, THIS.imageHeight);
		
		// 影生成I理
		var shadow = new THIS(window, parent);
		shadow.assignImages(this);
		// Tりつぶし
		shadow.face = dfMain;
		shadow.holdAlpha = true;
		shadow.fillRect(THIS.imageLeft, THIS.imageTop, THIS.imageWidth, THIS.imageHeight, shadowColor);
		shadow.face = dfBoth;
		shadow.holdAlpha = false;
		// ぼかす
		shadow.doBoxBlur(blur, blur);
		
		// 影をコピ`
		work.operateRect(THIS.imageLeft + dx, THIS.imageTop + dy, shadow, THIS.imageLeft, THIS.imageTop, THIS.imageWidth, THIS.imageHeight, ltPsNormal, shadowOpacity);
		// 自分をコピ`
		work.operateRect(THIS.imageLeft, THIS.imageTop, this, THIS.imageLeft, THIS.imageTop, THIS.imageWidth, THIS.imageHeight, ltPsNormal, 255);
		
		// 画像さしかえ
		THIS.assignImages(work);
		
		// 後片付け
		invalidate work;
		invalidate shadow;
	};
}

