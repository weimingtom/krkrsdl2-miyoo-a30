//;# MainWindow.tjs - KAG メインウィンドウ
//;# Copyright (C)2001-2008, W.Dee and contributors  改?配布は自由です
//;<<'END_OF_TJS_SCRIPT';

// このスクリプトは有郡 perl5 スクリプトでもある

class KAGWindow extends Window
{
	// KAG のウィンドウ クラス
	// KAG の幼鳏违幞ぅ螭什糠证悉长长擞述してある

	// 以下のうち、/*C*/ のつく涫は、末端の perl スクリプトによって
	// 自拥膜荬衰偿冤`されるコ`ドが生成される涫

	var scWidth = 640; // 画面横幅
	var scHeight = 480; // 画面k幅

	var aboutWidth = 320; // 「このソフトについて」ウィンドウの横幅
	var aboutHeight = 200; // 同k幅

	var isFirstProcess = true; // 一番最初の process の呼び出しかどうか

	var freeSaveDataMode = false; // 荬颔幞衰濠`バ`などで管理せずに、eのファイルとして管理する
	var saveThumbnail = false; // サムネイルを保存するかどうか
	var thumbnailWidth = 133; // サムネイルの横幅
	var thumbnailDepth = 8; // サムネイルのBMPモ`ド。8か24
		// サムネイルの フルカラ`化およびサイズフリ`化のパッチは
		// ゆん氏からいただきました。
		// この訾蚪瑜辘皮礼申し上げます。


	var snapshotLayer = void; // 画像のスナップショットを一r的に保存するレイヤ
	var snapshotLockCount = 0; // ロックカウント

	var lastSaveDataNameGlobal = ""; // 最後に保存したフリ`セ`ブモ`ドでのファイル名
	/*C*/var lastSaveDataName = ""; // 最後に保存したフリ`セ`ブモ`ドでのファイル名

	var saveDataLocation = System.dataPath; // セ`ブデ`タ保存鏊

	var saveDataID = "00000000-0000-0000-0000-000000000000"; // セ`ブデ`タの ID

	var readOnlyMode = false; // iみzみ用モ`ド(デ`タをディスクにかない)
	var dataName = "data"; // セ`ブデ`タ名
	var saveDataMode = ""; // デ`タ保存モ`ド( "c" で暗号化 )

	var recordHistoryOfStore = 0; // 通^履sをhするかどうか
		// 0 = 自拥膜摔嫌hしない  1 = 保存可能なラベルごと
		// 2 = xk肢 ( @s タグ ) ごと
	var maxHistoryOfStore = 5; // 通^hの最大数
	var historyOfStore = []; // 通^履sデ`タ
	var nextRecordHistory = false;
		// 次の保存可能なラベル通^rにF在の情螭虮４妞工毪どうか

	var stablePosibility = false;
		// 荬虮４婵赡埭圣楗佶腴gで stable になる可能性があるかどうか

	var fullScreened = false; // F在フルスクリ`ンかどうか

	var isMain = true; // これがメインウィンドウかどうか

	var askOnClose = true; // K了rにK了するかをユ`ザにくかどうか

	var helpFile = ""; // 「ヘルプ > 目次」で_くファイル

	var quakeTimer; // quake 用のタイマ
	var defaultQuakeTimeInChUnit = false;
	/*C*/var quaking = false; // eれているか
	/*C*/var quakeEndTick = 0; // eれをK了させる tick
	/*C*/var quakeHorzMax = 0; // 横振幅
	/*C*/var quakeVertMax = 0; // k振幅
	/*C*/var quakePhase = 0;

	var chDefaultAntialiased; // 文字にアンチエイリアスをかけるかどうか
	var chDefaultFace; // 文字のデフォルトのフォント

	var initialMessageLayerVisible = true;

	var historyLayer; // メッセ`ジ履sレイヤ
	/*C*/var historyWriteEnabled = true; // メッセ`ジレイヤに文字を出力するか
	/*C*/var historyEnabled = true; // メッセ`ジ履sレイヤを表示可能か
	var historyShowing = false; // メッセ`ジ履sレイヤを表示中か
	var lastHistoryHiddenTick = 0; // 最後に履sレイヤが非表示になったときの tick

	/*C*/var numCharacterLayers = 0; // 前景レイヤの数
	/*C*/var numMessageLayers = 1; // メッセ`ジレイヤの数

	var _primaryLayer;
	property primaryLayer { getter { return fore.base; } };

	var fore = %[]; // 表レイヤ
	var back = %[]; // Yレイヤ

	var scPositionX = %[]; // 立ち}の中心座(X)

	var tempLayer = void; // 一r的なレイヤ

	var lineBreak; // 行待ち用アニメ`ションレイヤ
	var pageBreak; // ペ`ジ待ち用グリフのアニメ`ションレイヤ
	var clickWaiting = false; // クリック待ちかどうか

	var mainConductor; // メインのコンダクタ
	var extraConductor; // 予浃违偿螗昆タ
	var conductor; // F在のコンダクタ
	var usingExtraConductor = false; // 予浃违偿螗昆タを使用中かどうか
	var onExtraConductorReturn; // extraConductor から通常のコンダクタにるときによぶv数

	var tagHandlers; // タグのハンドラ群辞配列

	var saveMacros = true; // マクロを荬吮４妞工毪どうか

	var current; // F在操作中のメッセ`ジレイヤ
	/*C*/var currentNum; // F在操作中のメッセ`ジレイヤ番号
	/*C*/var currentPage; // F在操作中のメッセ`ジレイヤのペ`ジ(表0/Y1)
	/*C*/var currentWithBack = false; // Y画面にも文字を描画するかどうか

	var bgm; // BGM オブジェクト

	var numSEBuffers = 1; // 抗音バッファの数
	var se = []; // 抗音バッファオブジェクト

	var numMovies = 1; // ム`ビ`オブジェクト数
//	var movie; // ム`ビ`オブジェクト
	var movies = []; // ム`ビ`オブジェクト

	var transCount; // F在M行中のトランジションの数
	var moveCount; // F在M行中の自右婴问

	var chSpeeds = %[
		fast: 10, // 「高速」文字表示スピ`ド
		normal: 30, // 「普通」文字表示スピ`ド
		slow: 50, // 「Wい」文字表示スピ`ド
		];

	var userChSpeed = 30; // ユ`ザのxんだ文字表示スピ`ド
	var userCh2ndSpeed = -1; // ユ`ザのxんだ 既i部分の文字表示スピ`ド
	var chNonStopToPageBreak = false; // ペ`ジ末まで一荬苏iみMむか ( l タグをoするか )
	var ch2ndNonStopToPageBreak = false; // 既iの部分でペ`ジ末まで一荬苏iみMむか
	/*C*/var chUserMode = true; // 文字表示速度はF在ユ`ザのxんだものか
	/*C*/var chSpeed = 30; // F在の文字表示スピ`ド
	/*C*/var actualChSpeed = chSpeed; // gHの文字表示スピ`ド

	/*C*/var beforeNoWaitActualChSpeed; // nowait に入る前の actualChSpeed
	/*C*/var beforeNoWaitChUserMode; // nowait に入る前の chUserMode

	/*C*/var clickSkipEnabled = true; // クリックスキップが有郡
	/*C*/var nextSkipEnabled = true; // 次のxk肢(/未i)までMむが有郡
	var skipMode = 0; // スキップのモ`ド
		// 0=スキップなし, 1=クリック待ち号まで, 2=改ペ`ジ待ち号まで, 3=次の停止まで
		// 4=早送り
	var autoMode = false; // 自诱iみすすみモ`ドかどうか
	var autoModePageWait = 350; // 自诱iみすすみモ`ドrの改ペ`ジrのウェイト
	var autoModeLineWait = 50; // 自诱iみすすみモ`ドrの行クリック待ちrのウェイト
		// 上の二つは、ノ`ウェイトにしたい龊悉 0 ではなくて -4 を指定すること

	var skipKeyRepressed = false; // return あるいは space キ` ( f キ`などではない )
								// が押されると true になる ( スキップ解除rに false

	var autoModePageWaits = %[
		fast: 400,  // 自诱iみすすみモ`ドの改ペ`ジr ウェイト「短い」
		faster: 700,  // 自诱iみすすみモ`ドの改ペ`ジr ウェイト「やや短い」
		medium: 1000,  // 自诱iみすすみモ`ドの改ペ`ジr ウェイト「普通」
		slower: 1300, // 自诱iみすすみモ`ドの改ペ`ジr ウェイト「ややWい」
		slow: 2000, // 自诱iみすすみモ`ドの改ペ`ジr ウェイト「Wい」
		];

	var autoModeLineWaits = %[
		fast: 180,  // 自诱iみすすみモ`ドの行末 ウェイト「短い」
		faster: 240,  // 自诱iみすすみモ`ドの行末 ウェイト「やや短い」
		medium: 300,  // 自诱iみすすみモ`ドの行末 ウェイト「普通」
		slower: 360, // 自诱iみすすみモ`ドの行末 ウェイト「ややWい」
		slow: 500, // 自诱iみすすみモ`ドの行末 ウェイト「Wい」
		];

	/*C*/var canCancelSkipByClick = true; // クリックによりスキップ状Bのキャンセルができるか

	/*C*/var autoWCEnabled = false; // 自鹰ΕДぅ趣有郡どうか
	/*C*/var autoWCChars = ""; // 自鹰ΕДぅ趣颏ける文字
	var autoWCWaits = []; // 自鹰ΕДぅ趣违ΕДぅ

	var timeOrigin; // resetWait でO定されたrg原点
	var lastWaitTime; // wait mode=until でgHに待ったrg

	var stableHandlers = []; // システムが安定(クリック待ち/停止)したときに呼ばれる
	var runHandlers = []; // システムが走り始めたときに呼ばれる
	var inStable = true; // 安定しているとき(走行中でないとき) true
	var inSleep = false; // s タグで停止しているとき true

	var updateBeforeCh = 0; // 文字を描画する前にいったん画面描画に入るかどうかのカウント

	var messageLayerHiding = false; // ユ`ザによりメッセ`ジレイヤがLされているか

	/*C*/var rightClickEnabled = true; // 右クリックが有郡
	/*C*/var rightClickCall = false; // 右クリックで特定のル`チンを呼ぶか
	/*C*/var rightClickJump = false; // 右クリックかで特定のラベルにジャンプするか
	/*C*/var rightClickTarget = ""; // 右クリックでの呼び出し先
	/*C*/var rightClickStorage = ""; // 右クリックでの呼び出し先
	/*C*/var rightClickName = "default"; // 右クリックのメニュ`表示名
	/*C*/var rightClickCurrentMenuName = ""; // 右クリックのメニュ`にF在O定されている名前
	var rightClickDefaultName = ""; // 右クリックのデフォルトのメニュ`表示名

	/*C*/var lastClickGlyphVisible; // extraConductor を使用する直前にクリック待ち号が可だったかどうか
	var lastClickGlyphMessagePage;
		// extraConductor を使用する直前のクリック待ち号の表示されているメッセ`ジレイヤのペ`ジ
	var lastClickGlyphMessageNum; // 〃 番号
	var lastClickGlyphWhich; // 〃 "page" か "line" か
	var inSleepBeforeExtraConductor; // extraConductor を使用する直前が inSleep だったか

	// 通常のマウスカ`ソル
	/*C*/var cursorDefault = crArrow;  // 通常のマウスカ`ソル
	/*C*/var cursorPointed = crHandPoint;  // ボタン、リンク等をポイントしたrのマウスカ`ソル
	/*C*/var cursorWaitingClick = crArrow;  // クリック待ちのマウスカ`ソル
	/*C*/var cursorDraggable = crSizeAll; // ドラッグ可能な鏊用のマウスカ`ソル

	/*C*/var supportReadingKey = VK_SPACE; // 追加のiみMみキ`

	/*C*/var startAnchorEnabled = false; // 「最初にる」が使用可能かどうか

	/*C*/var storeEnabled = true; // ユ`ザが「荬颏悉丹唷攻幞衰濠`にアクセス可能かどうか
	/*C*/var restoreEnabled = true; // ユ`ザが「荬颏郡嗓搿攻幞衰濠`にアクセス可能かどうか
	var storeLabelPassed = false; // 保存可能なラベルを通^したかどうか
	/*C*/var currentLabel = ""; // F在のラベル
	/*C*/var currentPageName = ""; // F在のペ`ジ名
	var currentRecordName = ""; // F在のh名 ( trail_ストレ`ジ_ラベル )
	var autoRecordPageShowing = false; // ラベル通^hをするか

	var numBookMarks = 10; // メニュ`に用意する荬违单芝幞衰濠`目の数
	var showBookMarkDate = false; // メニュ`に荬颏悉丹螭廊崭r刻を表示するか

	var bookMarkNames = []; // メニュ`にO定されている荬蚊前
	var bookMarkDates = []; // 荬稳崭
	var bookMarkProtectedStates = []; // 荬保oされているかの情

	var showFixedPitchOnlyInFontSelector = false; // フォントxkで固定ピットフォントのみを表示するか

	var flags = %[]; // フラグ(ユ`ザ)
	var pflags = %[]; // 「保存可能なラベル」を通^したr点でのフラグ(ユ`ザ)
	var pcflags = %[]; // 〃 (コア)
	var sflags = %[]; // システム涫I域(ユ`ザ)
	var scflags = %[]; // システム涫I域(コア)
	var tflags = %[]; // 一rフラグ

	var tempBookMarks = []; // 一r的に保存した

	var clickCount = 0; // 左クリックカウント
	var lastMouseDownX; // 最後にクリックされた X 座
	var lastMouseDownY; // 最後にクリックされた Y 座

	var mouseKeyEnabledCount = 0; // マウスキ`が有郡どうか

	var kagPlugins = []; // KAG プラグイン

	var keyDownHook = []; // キ`が押されたときに呼び出される物
	var leftClickHook = []; // 左クリックされたときに呼び出される物
	var rightClickHook = []; // 右クリックされたときに呼び出される物

	var padKeyMap; // パッドボタン -> ハンドラ(キ`コ`ド)。コンストラクタ内でO定
	var padKeyMapReverse; // キ`コ`ド -> パッドボタン。コンストラクタ内でO定


	var holdPeriodEventQueue = [];	// 保留にされたム`ビ`のピリオドイベントキュ`
	var isLeavePeriodEvent = false;	// ム`ビ`のピリオドイベントを保留にするかどうか
	var isWaitPeriodEvent = false;	// ム`ビ`のピリオドイベント待ち状Bかどうか
	var waitedPeriodEventStorageName = void;	// ピリオドイベント待ちをコ`ルしたストレ`ジ名

	//------------------------------------------------------ コンストラクタ --

	function KAGWindow(ismain = true, width = 0, height = 0)
	{
		// コンストラクタ
		// 引数 : ismain : メインウィンドウとして作成されるのかどうか
		super.Window(); // Hクラスのコンストラクタを呼ぶ

		// コンフィギュレ`ション
		isMain = ismain;
		if(ismain)
		{
			(KAGWindow_config incontextof this)();
			(KAGWindow_config_override incontextof this)()
				if typeof global.KAGWindow_config_override != "undefined";
		}

		userChSpeed = chSpeed = actualChSpeed = chSpeeds.normal;
		autoModePageWait = autoModePageWaits.medium;
		autoModeLineWait = autoModeLineWaits.medium;

		askOnClose = false if !ismain;

		// saveDataLocation がフルパスでないようならば System.exePath を
		// 付け加える
		if(saveDataLocation.indexOf(":") == -1)
			saveDataLocation = System.exePath + saveDataLocation;

		// ログの出力先を saveDataLocation にする
		if(ismain) Debug.logLocation = saveDataLocation;

		// メニュ`アイテムの作成
		if(ismain) (KAGWindow_createMenus incontextof this)();
		if(typeof this.rightClickMenuItem != "undefined")
			rightClickDefaultName = rightClickCurrentMenuName = rightClickMenuItem.caption;

		if(typeof this.autoModeMediumMenuItem != "undefined")
			autoModeMediumMenuItem.checked = true;
		if(typeof this.windowedMenuItem != "undefined")
			windowedMenuItem.checked = true;
		if(typeof this.chNormalMenuItem != "undefined")
			chNormalMenuItem.checked = true;
		if(typeof this.ch2ndNoChangeMenuItem != "undefined")
			ch2ndNoChangeMenuItem.checked = true;

		if(ismain) (Menu_visible_config incontextof this)();

		createBookMarkSubMenus();

		// ウィンドウ外の{整
		if(ismain)
		{
			borderStyle = bsSingle;
			innerSunken = true;
		}
		else
		{
			borderStyle = bsDialog;
			innerSunken = false;
		}
		showScrollBars = false;
		if(ismain) caption = System.title;

		// システムタイトルをキャプションと同じに
		if(ismain) System.title = caption;

		// ウィンドウサイズの{整
		if(width != 0 && height != 0)
		{
			// 与えられたサイズをm用
			scWidth = width;
			scHeight = height;
		}
		setInnerSize(scWidth, scHeight);

		// quake 用タイマの作成
		quakeTimer = new Timer(onQuakeTimerInterval, '');
		add(quakeTimer);
		quakeTimer.interval = 50;

		add(_primaryLayer = new Layer(this, null));
		with (_primaryLayer) {
			.name = "プライマリレイヤ";
			.setSize(scWidth, scHeight);
			.fillRect(0,0,.width,.height,0);
			.type = ltOpaque;
			.visible = true;
			//.hasImage = false;
			.onMouseDown = function (x, y, btn) {
				switch (btn) {
				case mbLeft:  window.onPrimaryClick();      break;
				case mbRight: window.onPrimaryRightClick(); break;
				}
				return (global.Layer.onMouseDown incontextof this)(...);
			} incontextof _primaryLayer;
		}

		// 背景レイヤの作成
		fore.messages = [];
		back.messages = [];
		fore.layers = [];
		back.layers = [];
		fore.base = new BaseLayer(this, _primaryLayer, "表-背景");
		add(fore.base);
		fore.base.setImageSize(scWidth, scHeight);
		fore.base.setSizeToImageSize();
		fore.base.visible = true;
		back.base = new BaseLayer(this, _primaryLayer, "Y-背景");
		add(back.base);
		back.base.setImageSize(scWidth, scHeight);
		back.base.setSizeToImageSize();
		fore.base.setCompLayer(back.base);
		back.base.setCompLayer(fore.base);
		fore.base.freeImage();
		back.base.freeImage();

		fore.base.setDefaultCursor(cursorDefault);
		back.base.setDefaultCursor(cursorDefault);

		// メッセ`ジ履sレイヤの作成
		historyLayer = new HistoryLayer(this, fore.base);
		add(historyLayer);

		// 前景レイヤの作成
		allocateCharacterLayers(numCharacterLayers);

		// メッセ`ジレイヤの作成
		allocateMessageLayers(numMessageLayers, false);
		current = fore.messages[0];
		currentNum = 0;
		currentPage = 0;
		currentWithBack = false;
		if(initialMessageLayerVisible)
		{
			fore.messages[0].visible = true;
			back.messages[0].visible = true;
		}

		chDefaultAntialiased = fore.messages[0].defaultAntialiased;
			// 文字にアンチエイリアスをかけるかどうか
		chDefaultFace = fore.messages[0].userFace;
			// 文字のデフォルトのフォント

		if(typeof this.chAntialiasMenuItem != "undefined")
			chAntialiasMenuItem.checked = chDefaultAntialiased;

		// 行待ち/ペ`ジ待ちアニメ`ションレイヤの作成
		lineBreak = new ClickGlyphLayer(this, fore.base);
		add(lineBreak);
		lineBreak.name = "行クリック待ち号";
		pageBreak = new ClickGlyphLayer(this, fore.base);
		add(pageBreak);
		pageBreak.name = "ペ`ジ末クリック待ち号";

		// タグハンドラ/コンダクタを作成
		tagHandlers = getHandlers();
		mainConductor = new Conductor(this, tagHandlers);
		add(mainConductor);
		conductor = mainConductor;
		extraConductor = new Conductor(this, tagHandlers);
		add(extraConductor);

		// BGM オブジェクトを作成
		bgm = new BGM(this);
		add(bgm);

		// 抗音オブジェクトを作成
		for(var i = 0; i < numSEBuffers; i++)
			add(se[i] = new SESoundBuffer(this, i));

		// ム`ビ`オブジェクトを作成
		if(ismain)
		{
			for( var i = 0; i < numMovies; i++)
				add(movies[i] = new Movie(this,i));
		}

		// デフォルトのハンドラを追加
		stableHandlers.add(defaultStableHandler);
		runHandlers.add(defaultRunHandler);

		// システム涫のiみzみ
		if(ismain) loadSystemVariables();

		// システム涫を反映
		if(ismain)
		{
			setSystemStateFromSystemVariables();
			setBookMarkMenuCaptions();
		}

		// メッセ`ジレイヤのクリア
		clearMessageLayers(false);

@if (kirikiriz==0)
		// ウィンドウ位置の{
		if(this.width + this.left > System.desktopLeft + System.desktopWidth)
			left = ((System.desktopWidth - this.width) >>1) + System.desktopLeft;
		if(this.height + this.top > System.desktopTop + System.desktopHeight)
			top = ((System.desktopHeight - this.height) >>1) + System.desktopTop;
@endif

		// パッドボタンハンドラの作成
		createPadKeyMap();


		// ウィンドウを表示
		if(ismain) visible = true;

		// 画面サイズがウィンドウサイズよりも小さい龊悉
		// フルスクリ`ンにしてみる
		if(ismain)
		{
			if(System.screenWidth <= scWidth && System.screenHeight <= scHeight)
				onFullScreenMenuItemClick(this);
		}

		// 前回起rにフルスクリ`ンだった龊悉膝榨毳攻リ`ンにしてみる
		if(ismain)
		{
			if(scflags.fullScreen !== void && +scflags.fullScreen)
				onFullScreenMenuItemClick(this);
		}

		// いったんシステム涫をき出す
		if(ismain) saveSystemVariables();
	}

	//------------------------------------------------------------- finalize --

	function finalize()
	{
		// finalize メソッド
        clearBgmStop();
        clearBgmLabel();

		// プラグインのo炕
		for(var i = 0; i < kagPlugins.count; i++) invalidate kagPlugins[i];

		// 前景、メッセ`ジレイヤをo炕
		for(var i = 0; i< fore.layers.count; i++) invalidate fore.layers[i];
		for(var i = 0; i< back.layers.count; i++) invalidate back.layers[i];
		for(var i = 0; i< fore.messages.count; i++) invalidate fore.messages[i];
		for(var i = 0; i< back.messages.count; i++) invalidate back.messages[i];

		// snapshotLayer をo炕
		invalidate snapshotLayer if snapshotLayer !== void;

		// tempLayer をo炕
		invalidate tempLayer if tempLayer !== void;

		// ス`パ`クラスの finalize を呼ぶ
		super.finalize(...);
	}

	//-------------------------------------------------- onCloseQuery/close --

	function onCloseQuery()
	{
		saveSystemVariables();
		if(!askOnClose) { super.onCloseQuery(true); return; }
		super.onCloseQuery(askYesNo("K了しますか？"));
	}

	function close()
	{
		// ウィンドウを]じる
		saveSystemVariables();
		super.close(...);
	}

	function shutdown()
	{
		// ウィンドウを]じるが、K了_Jを行わない
		// このメソッド内で close をすると、々な
		// オブジェクトがo炕されてしまい、この
		// v数からった先でエラ`がk生する。
		// そのため、いったん AsyncTrigger を介して、
		// 全てのメソッドからったあとにシャットダウン
		// I理を行う。
		global.shutdownTrigger =
			new AsyncTrigger(handleShutdown, '');
		global.shutdownTrigger.cached = true;
		global.shutdownTrigger.trigger();
		if(conductor.status == conductor.mRun)
			conductor.interrupt();
			// コンダクタが走行中のrは
			// コンダクタに中断を护à
	}

	function handleShutdown()
	{
		// shutdown() からのシャットダウン要求を
		// gHにI理するメソッド
		var askOnClose_save = askOnClose;
		askOnClose = false;
		close();
		if(this isvalid) askOnClose = askOnClose_save;
	}

	function closeByScript(elm)
	{
		// ウィンドウを]じる
		// ちょっと面倒くさいとをやっているのは
		// shutdown と同じ理由
		// 「いいえ」がxkされてウィンドウが]じなかった龊悉
		// 'not_closed' トリガがk行され、g行は再_する。
		var askOnClose_save = askOnClose;
		if(elm.ask !== void && !(+elm.ask)) askOnClose = false;
		global.shutdownTrigger =
			new AsyncTrigger(handleCloseByScript, '');
		global.shutdownTrigger.cached = true;
		global.shutdownTrigger.trigger();

		// closeByScript は、このハンドラがKわった直後に
		// 「K了しますか？」のダイアログを表示する。
		// K了する龊悉悉饯韦蓼藿K了する。
		// K了しない龊悉 'not_closed' トリガがk行され、
		// g行は@Aする。
		conductor.wait(%[
			not_closed : askOnClose_save
			? (function
			{
				// gHにこれが呼ばれることはないが、一
				askOnClose = true;
			} incontextof this)
			: (function
			{
			} incontextof this)
			]);
	}

	function handleCloseByScript()
	{
		// shutdown() からのシャットダウン要求を
		// gHにI理するメソッド
		close();
		if(this isvalid) // いいえ がxkされた龊
			conductor.trigger('not_closed');
	}

	//------------------------------------------------------ プラグインI理 --

	function forEachEventHook(method, func, arg)
	{
		// すべてのプラグインオブジェクトの method にたいして
		// func をg行する
		// func の引数には各要素と arg が渡される
		if(kagPlugins.count)
		{
			var array = [];
			array.assign(kagPlugins); // いったんコピ`し、コピ`した物にしてg行する
			var arraycount = array.count;
			for(var i =0; i<arraycount; i++)
			{
				var obj = array[i];
				if(typeof obj[method] != "undefined")
					func(obj[method], arg);
			}
		}
	}

	function addPlugin(plugin)
	{
		// プラグインオブジェクトを追加
		kagPlugins.add(plugin);
	}

	function removePlugin(plugin)
	{
		// プラグインオブジェクトを削除
		kagPlugins.remove(plugin);
	}

	//---------------------------------------------------------- フックI理 --

	function callHook(array, arg1, arg2, arg3)
	{
		if(array.count)
		{
			var processed = false;
			var newarray = [];
			newarray.assign(array);
			var arraycount = newarray.count;
			for(var i  = 0; i < arraycount; i++)
			{
				var func = newarray[i];
				var ret = func(arg1, arg2, arg3);
				processed = processed || ret;
			}
			return processed;
		}
		else
		{
			return false;
		}
	}

	//------------------------------------------ パッドのキ`マッピング作成 --

	function createPadKeyMap()
	{
		// パッド入力とそれに辘工幼鳏违蕙氓豫螗啊
		// 胜扦鲜字キ`はキ`ボ`ドのカ`ソルキ`にマッピング、
		// ボタン1 は Return、ボタン2 は ESC、ボタン3 は メッセ`ジ履sの表示
		// にマッピングされる。
		// v数を指定した龊悉膝堀骏螭蜓氦筏郡趣にはそのv数が呼ばれる。

		padKeyMap = %[
			VK_PADLEFT =>		VK_LEFT,
			VK_PADRIGHT =>		VK_RIGHT,
			VK_PADUP =>			VK_UP,
			VK_PADDOWN =>		VK_DOWN,
			VK_PAD1 =>			VK_RETURN,
			VK_PAD2 =>			VK_ESCAPE,
			VK_PAD3 =>
				function(ev) {
					showHistoryByKey(this);
				},
			];

		// padKeyMapReverse を作成
		padKeyMapReverse = %[];
		var ar = [];
		ar.assign(padKeyMap);
		for(var i = 0; i < ar.count; i += 2)
		{
			if(typeof(ar[i+1]) != "Object")
			{
				padKeyMapReverse[ar[i+1]] = ar[i];
			}
		}
	}

	function getKeyState(key)
	{
		// System.getKeyState v数と同等だが、パッドのキ`にvしても
		// 反辘蚍丹
		var sg = System.getKeyState;
		var state = sg(key);
		if(state) return true;
		var pad_key = padKeyMapReverse[key];
		if(pad_key !== void)
		{
			// キ`コ`ド -> パッドのキ`コ`ドのQがつかった
			return sg(pad_key);
		}
		return false;
	}

	//-------------------------------------------------------------- action --

	function action(ev)
	{
		if(ev.type == 'onKeyDown' && ev.target === this)
		{
			// パッド入力に辘工I理
			var handler = padKeyMap[ev.key];
			if(handler !== void)
			{
				// ハンドラがつかった
				if(typeof(handler) == "Object")
				{
					// ハンドラはv数
					(handler incontextof this)(ev);
				}
				else
				{
					// ハンドラはキ`コ`ド
					postInputEvent('onKeyDown', %[key: handler]);
					postInputEvent('onKeyUp', %[key: handler]);
				}
			}
		}
	}

	//------------------------------------------------------ tempLayer vB --

	property temporaryLayer
	{
		// ワ`クエリアとして一r的に使用できるレイヤを返す
		getter()
		{
			if(tempLayer === void)
			{
				tempLayer = new KAGLayer(this, primaryLayer);
				tempLayer.name = "一rワ`クレイヤ";
			}
			return tempLayer;
		}
	}

	//------------------------------------------------ メニュ`アイテムvB --

	function onExitMenuItemClick(sender)
	{
		close();
	}

	function onRightClickMenuItemClick(sender)
	{
		onPrimaryRightClick(); // 右クリックの幼
	}

	function onShowHistoryMenuItemClick(sender)
	{
		if(historyLayer.visible) hideHistory(); else showHistory();
	}

	function onSkipToNextStopMenuItemClick(sender)
	{
		skipToStop();
	}

	function onAutoModeMenuItemClick(sender)
	{
		if(autoMode) cancelAutoMode(); else enterAutoMode();
	}

	function onAutoModeWaitMenuClick(sender)
	{
		sender.checked = true;
		autoModePageWait = sender.wait;
		autoModeLineWait = sender.lwait;
	}

	function onBackStartMenuItemClick(sender)
	{
		goBackHistory();
	}

	function onGoToStartMenuItemClick(sender)
	{
		goToStartWithAsk();
	}

	function onChSpeedMenuItemClick(sender)
	{
		sender.checked = true;
		userChSpeed = sender.speed;
		setUserSpeed();
		saveSystemVariables();
	}

	function onChNonStopToPageBreakItemClick(sender)
	{
		chNonStopToPageBreak = ! chNonStopToPageBreak;
		if(typeof this.chNonStopToPageBreakItem != "undefined")
			chNonStopToPageBreakItem.checked = chNonStopToPageBreak;
			saveSystemVariables();
	}

	function onCh2ndNonStopToPageBreakItemClick(sender)
	{
		ch2ndNonStopToPageBreak = ! ch2ndNonStopToPageBreak;
		if(typeof this.ch2ndNonStopToPageBreakItem != "undefined")
			ch2ndNonStopToPageBreakItem.checked = ch2ndNonStopToPageBreak;
			saveSystemVariables();
	}

	function onCh2ndSpeedMenuItemClick(sender)
	{
		sender.checked = true;
		userCh2ndSpeed = sender.speed;
		setUserSpeed();
		saveSystemVariables();
	}

	function onChAntialiasMenuItemClick(sender)
	{
		chDefaultAntialiased = !chDefaultAntialiased;
		if(typeof this.chAntialiasMenuItem != "undefined")
			chAntialiasMenuItem.checked = chDefaultAntialiased;
		setMessageLayerUserFont();
		saveSystemVariables();
	}

	function onChChangeFontMenuItem(sender)
	{
		selectFont();
		saveSystemVariables();
	}

	function onRestoreMenuClick(sender)
	{
		if(!freeSaveDataMode) return;
		loadBookMarkFromFileWithAsk();
	}

	function onStoreMenuClick(sender)
	{
		if(!freeSaveDataMode) return;
		saveBookMarkToFileWithAsk();
	}

	function onWindowedMenuItemClick(sender)
	{
		if(fullScreened)
		{
			try
			{
				fullScreen = false;
			}
			catch(e)
			{
				Debug.notice("ウィンドウモ`ドに移行できませんでした : " + e.message);
			}
			fullScreened = fullScreen;
			if(fullScreened)
				fullScreenMenuItem.checked = true;
			else
				windowedMenuItem.checked = true;
		}
		saveSystemVariables();
	}

	function onFullScreenMenuItemClick(sender)
	{
		if(!fullScreened)
		{
			try
			{
				fullScreen = true;
			}
			catch(e)
			{
				Debug.notice("フルスクリ`ンモ`ドに移行できませんでした : " + e.message);
			}
			fullScreened = fullScreen;
			if(fullScreened)
				fullScreenMenuItem.checked = true;
			else
				windowedMenuItem.checked = true;
		}
		saveSystemVariables();
	}

	function onHelpIndexMenuItemClick(sender)
	{
		// ヘルプファイルを_く
		System.shellExecute(Storages.getLocalName(System.exePath) + helpFile);
	}

	function onHelpAboutMenuItemClick(sender)
	{
		// 「このソフトについて」ウィンドウを表示
		var win = new global.KAGWindow(false, aboutWidth, aboutHeight);
		win.setPos(left + ((width - win.width)>>1), top + ((height - win.height)>>1));
		win.process('about.ks' ,,, true); // about.ks を immediate で表示
		win.showModal(); // モ`ド付きで表示
		invalidate win;
	}

	function onReloadScenarioMenuItemClick(sender)
	{
		saveBookMark(1000, false);
		loadBookMark(1000);
	}

	function onShowConsoleMenuItemClick(sender)
	{
		Debug.console.visible = true;
	}

	function onShowContollerMenuItemClick(sender)
	{
		Debug.controller.visible = true;
	}

	function internalSetMenuAccessibleAll(menu, state)
	{
		// autoEnable が true のすべてのメニュ`目の accessible に state を
		// O定する
		if(typeof menu.autoEnable != "undefined" && menu.autoEnable)
			menu.accessible = state;
		if(typeof menu.stopRecur == "undefined" || !menu.stopRecur)
		{
			var children = menu.children;
			for(var i = children.count -1; i >= 0; i--)
				internalSetMenuAccessibleAll(children[i], state); // 再
		}
	}

	function canStore()
	{
		return storeEnabled && storeLabelPassed;
	}

	function canRestore()
	{
		return restoreEnabled;
	}

	function setMenuAccessibleAll()
	{
		// メニュ`目の使用可/不可をO定する

		// autoEnable が true のすべてのメニュ`目の accessible の
		// をO定する
		var notmodal = !historyLayer.visible && !messageLayerHiding;
		var state = inStable && notmodal;
		internalSetMenuAccessibleAll(menu, state);

		// その他のメニュ`の使用可/不可
		if(typeof this.skipToNextStopMenuItem != "undefined")
			skipToNextStopMenuItem.enabled = state && !inSleep && nextSkipEnabled;

		if(typeof this.rightClickMenuItem != "undefined")
			rightClickMenuItem.enabled = inStable && !historyLayer.visible;

		if(typeof this.showHistoryMenuItem != "undefined")
			showHistoryMenuItem.enabled = inStable && !messageLayerHiding &&
				historyEnabled;

		if(typeof this.autoModeMenuItem != "undefined")
			autoModeMenuItem.enabled = notmodal;

		if(typeof this.goBackMenuItem != "undefined")
			goBackMenuItem.enabled = state && isHistoryOfStoreAlive();

		if(typeof this.goToStartMenuItem != "undefined")
			goToStartMenuItem.enabled = state && startAnchorEnabled;

		if(typeof this.storeMenu != "undefined")
		{
			var st = state && canStore();
			var children = storeMenu.children;
			if(freeSaveDataMode) storeMenu.enabled = st;
			for(var i = children.count - 1; i >= 0; i--)
			{
				var obj = children[i];
				obj.enabled = obj.orgEnabled && st;
			}
		}

		if(typeof this.restoreMenu != "undefined")
		{
			var st = state && canRestore();
			var children = restoreMenu.children;
			if(freeSaveDataMode) restoreMenu.enabled = st;
			for(var i = children.count - 1; i >= 0; i--)
			{
				var obj = children[i];
				obj.enabled = obj.orgEnabled && st;
			}
		}
	}

	//----------------------------------------------- マウスキ`を有郡摔工 --

	function enableMouseKey()
	{
		// マウスキ`を有郡摔工
		if(mouseKeyEnabledCount == 0)
		{
			useMouseKey = true;
			mouseCursorState = mcsVisible;
		}
		mouseKeyEnabledCount++; // 参照カウンタ方式
	}

	function disableMouseKey()
	{
		// マウスキ`をo郡摔工
		mouseKeyEnabledCount --;
		if(mouseKeyEnabledCount == 0) useMouseKey = false;
	}

	//----------------------------------------------------- システム涫vB --

	function loadSystemVariables()
	{
		// システム涫のiみzみ
		try
		{
			var fn = saveDataLocation + "/" + dataName +
				"sc.ksd";
			if(Storages.isExistentStorage(fn))
			{
				scflags = Scripts.evalStorage(fn);
				scflags = %[] if scflags === void;
			}
			else
			{
				scflags = %[];
			}

			var fn = saveDataLocation + "/" + dataName +
				"su.ksd";
			if(Storages.isExistentStorage(fn))
			{
				sflags = Scripts.evalStorage(fn);
				sflags = %[] if sflags === void;
			}
			else
			{
				sflags = %[];
			}
		}
		catch(e)
		{
			throw new Exception("システム涫デ`タをiみzめないか、"
				"あるいはシステム涫デ`タが菠欷皮い蓼(" + e.message + ")");
		}
	}

	function setSystemStateFromSystemVariables()
	{
		// システム涫に基づいてシステムをO定
		// (フルスクリ`ンvBをのぞく)
		if(scflags.autoModePageWait !== void)
		{
			if(typeof this.autoModeWaitMenu !== "undefined")
			{
				var children = autoModeWaitMenu.children;
				for(var i = children.count-1; i >= 0; i--)
				{
					var item = children[i];
					if(typeof item.wait !== "undefined" && item.wait == scflags.autoModePageWait)
					{
						item.checked = true;
						break;
					}
				}
			}
		}

		if(scflags.userChSpeed !== void)
		{
			if(typeof this.chSpeedMenu !== "undefined")
			{
				var children = chSpeedMenu.children;
				for(var i = children.count-1; i >= 0; i--)
				{
					var item = children[i];
					if(typeof item.speed !== "undefined" && item.speed == scflags.userChSpeed)
					{
						item.checked = true;
						break;
					}
				}
			}
		}

		if(scflags.userCh2ndSpeed !== void)
		{
			if(typeof this.chSpeedMenu !== "undefined")
			{
				var children = ch2ndSpeedMenu.children;
				for(var i = children.count-1; i >= 0; i--)
				{
					var item = children[i];
					if(typeof item.speed !== "undefined" && item.speed == scflags.userCh2ndSpeed)
					{
						item.checked = true;
						break;
					}
				}
			}
		}

		lastSaveDataNameGlobal = scflags.lastSaveDataNameGlobal if scflags.lastSaveDataNameGlobal !== void;

		bookMarkNames = scflags.bookMarkNames if scflags.bookMarkNames !== void;
		bookMarkDates = scflags.bookMarkDates if scflags.bookMarkDates !== void;
		bookMarkProtectedStates = scflags.bookMarkProtectedStates if scflags.bookMarkProtectedStates !== void;

		autoModePageWait = scflags.autoModePageWait if scflags.autoModePageWait !== void;
		autoModeLineWait = scflags.autoModeLineWait if scflags.autoModeLineWait !== void;
		userChSpeed = scflags.userChSpeed if scflags.userChSpeed !== void;
		userCh2ndSpeed = scflags.userCh2ndSpeed if scflags.userCh2ndSpeed !== void;

		setUserSpeed();

		chNonStopToPageBreak = scflags.chNonStopToPageBreak if scflags.chNonStopToPageBreak !== void;
		if(typeof this.chNonStopToPageBreakItem != "undefined")
			chNonStopToPageBreakItem.checked = chNonStopToPageBreak;

		ch2ndNonStopToPageBreak = scflags.ch2ndNonStopToPageBreak if scflags.ch2ndNonStopToPageBreak !== void;
		if(typeof this.ch2ndNonStopToPageBreakItem != "undefined")
			ch2ndNonStopToPageBreakItem.checked = ch2ndNonStopToPageBreak;

		chDefaultAntialiased = scflags.chDefaultAntialiased if scflags.chDefaultAntialiased !== void;
		if(typeof this.chAntialiasMenuItem != "undefined")
			chAntialiasMenuItem.checked = chDefaultAntialiased;
		chDefaultFace = scflags.chDefaultFace if scflags.chDefaultFace !== void;

		setMessageLayerUserFont();

		bgm.restoreSystemState(scflags);

		for(var i = 0; i<numSEBuffers; i++)
		{
			se[i].restoreSystemState(scflags);
		}
	}

	function clearSystemVariables()
	{
		// システム涫のクリア
		(Dictionary.clear incontextof sflags)();
	}

	function saveSystemVariables()
	{
		// システム涫の保存
		if(!isMain) return;

		// プラグインを呼ぶ
		forEachEventHook('onSaveSystemVariables',
			function(handler, f) { handler(); } incontextof this);

		// フルスクリ`ン
		scflags.fullScreen = fullScreened;

		// 文字表示速度
		scflags.autoModePageWait = autoModePageWait;
		scflags.autoModeLineWait = autoModeLineWait;
		scflags.userChSpeed = userChSpeed;
		scflags.userCh2ndSpeed = userCh2ndSpeed;
		scflags.chDefaultAntialiased = chDefaultAntialiased;
		scflags.chDefaultFace = chDefaultFace;
		scflags.chNonStopToPageBreak = chNonStopToPageBreak;
		scflags.ch2ndNonStopToPageBreak = ch2ndNonStopToPageBreak;

		// ブックマ`ク名
		scflags.bookMarkNames = bookMarkNames; // (コピ`ではなくて)参照で十分
		scflags.bookMarkDates = bookMarkDates;
		scflags.bookMarkProtectedStates = bookMarkProtectedStates;

		scflags.lastSaveDataNameGlobal = lastSaveDataNameGlobal;

		// ファイルにきzむ
		if(!readOnlyMode)
		{
			var fn = saveDataLocation + "/" + dataName +
				"sc.ksd";
			(Dictionary.saveStruct incontextof scflags)(fn, saveDataMode);

			var fn = saveDataLocation + "/" + dataName +
				"su.ksd";
			(Dictionary.saveStruct incontextof sflags)(fn, saveDataMode);
		}
	}

	//------------------------------------------------------- ゲ`ム涫vB --

	function internalStoreFlags(f)
	{
		// f にF在の状Bをhする

		// KAGWindow にvするもの
		(Dictionary.clear incontextof f)(); // クリア
		// ここの [start_store_vars] から [end_store_vars] で欷蓼欷坎糠证
		// 末端の perl スクリプトによって自拥膜I理されるので、このマ`クを消したり
		// このマ`クのgを集したりしないこと。
		// [start_store_vars]
		f.lastSaveDataName = lastSaveDataName;
		f.quaking = quaking;
		f.quakeEndTick = quakeEndTick;
		f.quakeHorzMax = quakeHorzMax;
		f.quakeVertMax = quakeVertMax;
		f.quakePhase = quakePhase;
		f.historyWriteEnabled = historyWriteEnabled;
		f.historyEnabled = historyEnabled;
		f.numCharacterLayers = numCharacterLayers;
		f.numMessageLayers = numMessageLayers;
		f.currentNum = currentNum;
		f.currentPage = currentPage;
		f.currentWithBack = currentWithBack;
		f.chUserMode = chUserMode;
		f.chSpeed = chSpeed;
		f.actualChSpeed = actualChSpeed;
		f.beforeNoWaitActualChSpeed = beforeNoWaitActualChSpeed;
		f.beforeNoWaitChUserMode = beforeNoWaitChUserMode;
		f.clickSkipEnabled = clickSkipEnabled;
		f.nextSkipEnabled = nextSkipEnabled;
		f.canCancelSkipByClick = canCancelSkipByClick;
		f.autoWCEnabled = autoWCEnabled;
		f.autoWCChars = autoWCChars;
		f.rightClickEnabled = rightClickEnabled;
		f.rightClickCall = rightClickCall;
		f.rightClickJump = rightClickJump;
		f.rightClickTarget = rightClickTarget;
		f.rightClickStorage = rightClickStorage;
		f.rightClickName = rightClickName;
		f.rightClickCurrentMenuName = rightClickCurrentMenuName;
		f.lastClickGlyphVisible = lastClickGlyphVisible;
		f.cursorDefault = cursorDefault;
		f.cursorPointed = cursorPointed;
		f.cursorWaitingClick = cursorWaitingClick;
		f.cursorDraggable = cursorDraggable;
		f.supportReadingKey = supportReadingKey;
		f.startAnchorEnabled = startAnchorEnabled;
		f.storeEnabled = storeEnabled;
		f.restoreEnabled = restoreEnabled;
		f.currentLabel = currentLabel;
		f.currentPageName = currentPageName;
		// [end_store_vars]

		// perl スクリプトによって自拥膜I理されないもの、いくつか。
		// 自鹰ΕДぅ
		f.autoWCWaits = [];
		f.autoWCWaits.assign(autoWCWaits); // 自鹰ΕДぅ趣违ΕДぅ

		// bgm
		f.bgm = bgm.store();

		// 抗音
		f.se = [];
		for(var i = 0; i<numSEBuffers; i++)
		{
			f.se[i] = se[i].store();
		}

		// メッセ`ジレイヤ
		f.foreMessageLayers = [];
		f.backMessageLayers = [];
		for(var i = 0; i < numMessageLayers; i++)
		{
			f.foreMessageLayers[i] = fore.messages[i].store();
			f.backMessageLayers[i] = back.messages[i].store();
		}

		// 前景レイヤ
		f.foreCharacterLayers = [];
		f.backCharacterLayers = [];
		for(var i = 0; i < numCharacterLayers; i++)
		{
			f.foreCharacterLayers[i] = fore.layers[i].store();
			f.backCharacterLayers[i] = back.layers[i].store();
		}

		// 背景レイヤ
		f.foreBaseLayer = fore.base.store();
		f.backBaseLayer = back.base.store();

		// ウィンドウキャプション
		f.caption = caption;

		// コンダクタ
		f.mainConductor = mainConductor.store();
		if(!saveMacros) f.mainConductor.macros = void;
			// マクロ情螭 void で上きすると葜肖违蕙ロ情螭o郡摔胜

		// メッセ`ジ履s
		if(historyLayer.storeState)
		{
			f.historyData = historyLayer.save();
		}

		// ム`ビ`
		if( isMain )
		{
			f.movies = [];
			for( var i = 0; i < numMovies; i++)
				f.movies[i] = movies[i].store();
		}

		// storeHook
		forEachEventHook('onStore',
			function(handler, f) { handler(f.flags, f.options); } incontextof this,
			%[flags:f, options:void]);
	}

	function storeFlags()
	{
		// pcflags, pflags にをきzむ

		// flags -> pflags
		(Dictionary.assignStruct incontextof pflags)(flags);

		internalStoreFlags(pcflags);
	}

	function internalRestoreFlags(f, clear = true, elm = void)
	{
		// f から情螭蛘iみ出す
		// clear が true ならばメッセ`ジレイヤをクリアする
		// se, bgm がそれぞれ true ならばその情螭夥从长丹护
		// backlay が true の龊悉稀⒈砘面にロ`ドすべきものをY画面にロ`ドする

		// KAGWindow にvするもの
		// ここの [start_restore_vars] から [end_restore_vars] で欷蓼欷坎糠证
		// (略)
		// [start_restore_vars]
		lastSaveDataName = f.lastSaveDataName if f.lastSaveDataName !== void;
		quaking = f.quaking if f.quaking !== void;
		quakeEndTick = f.quakeEndTick if f.quakeEndTick !== void;
		quakeHorzMax = f.quakeHorzMax if f.quakeHorzMax !== void;
		quakeVertMax = f.quakeVertMax if f.quakeVertMax !== void;
		quakePhase = f.quakePhase if f.quakePhase !== void;
		historyWriteEnabled = f.historyWriteEnabled if f.historyWriteEnabled !== void;
		historyEnabled = f.historyEnabled if f.historyEnabled !== void;
		numCharacterLayers = f.numCharacterLayers if f.numCharacterLayers !== void;
		numMessageLayers = f.numMessageLayers if f.numMessageLayers !== void;
		currentNum = f.currentNum if f.currentNum !== void;
		currentPage = f.currentPage if f.currentPage !== void;
		currentWithBack = f.currentWithBack if f.currentWithBack !== void;
		chUserMode = f.chUserMode if f.chUserMode !== void;
		chSpeed = f.chSpeed if f.chSpeed !== void;
		actualChSpeed = f.actualChSpeed if f.actualChSpeed !== void;
		beforeNoWaitActualChSpeed = f.beforeNoWaitActualChSpeed if f.beforeNoWaitActualChSpeed !== void;
		beforeNoWaitChUserMode = f.beforeNoWaitChUserMode if f.beforeNoWaitChUserMode !== void;
		clickSkipEnabled = f.clickSkipEnabled if f.clickSkipEnabled !== void;
		nextSkipEnabled = f.nextSkipEnabled if f.nextSkipEnabled !== void;
		canCancelSkipByClick = f.canCancelSkipByClick if f.canCancelSkipByClick !== void;
		autoWCEnabled = f.autoWCEnabled if f.autoWCEnabled !== void;
		autoWCChars = f.autoWCChars if f.autoWCChars !== void;
		rightClickEnabled = f.rightClickEnabled if f.rightClickEnabled !== void;
		rightClickCall = f.rightClickCall if f.rightClickCall !== void;
		rightClickJump = f.rightClickJump if f.rightClickJump !== void;
		rightClickTarget = f.rightClickTarget if f.rightClickTarget !== void;
		rightClickStorage = f.rightClickStorage if f.rightClickStorage !== void;
		rightClickName = f.rightClickName if f.rightClickName !== void;
		rightClickCurrentMenuName = f.rightClickCurrentMenuName if f.rightClickCurrentMenuName !== void;
		lastClickGlyphVisible = f.lastClickGlyphVisible if f.lastClickGlyphVisible !== void;
		cursorDefault = f.cursorDefault if f.cursorDefault !== void;
		cursorPointed = f.cursorPointed if f.cursorPointed !== void;
		cursorWaitingClick = f.cursorWaitingClick if f.cursorWaitingClick !== void;
		cursorDraggable = f.cursorDraggable if f.cursorDraggable !== void;
		supportReadingKey = f.supportReadingKey if f.supportReadingKey !== void;
		startAnchorEnabled = f.startAnchorEnabled if f.startAnchorEnabled !== void;
		storeEnabled = f.storeEnabled if f.storeEnabled !== void;
		restoreEnabled = f.restoreEnabled if f.restoreEnabled !== void;
		currentLabel = f.currentLabel if f.currentLabel !== void;
		currentPageName = f.currentPageName if f.currentPageName !== void;
		// [end_restore_vars]

		// perl スクリプトによって自拥膜I理されないもの、いくつか。

		// 自鹰ΕДぅ
		autoWCWaits.assign(f.autoWCWaits) if f.autoWCWaits !== void;

		// ム`ビ`
		if( isMain )
		{
			for( var i = 0; i < numMovies; i++)
				movies[i].restore(f.movies[i]);
		}

		// 背景レイヤ
		var backlay = elm != void && elm.backlay != void && +elm.backlay;
		if(backlay)
		{
			back.base.restore(f.foreBaseLayer);
		}
		else
		{
			fore.base.restore(f.foreBaseLayer);
			back.base.restore(f.backBaseLayer);
		}

		// メッセ`ジレイヤ
		allocateMessageLayers(numMessageLayers);
		if(backlay)
		{
			for(var i = 0; i < numMessageLayers; i++)
			{
				back.messages[i].restore(f.foreMessageLayers[i]);
			}
		}
		else
		{
			for(var i = 0; i < numMessageLayers; i++)
			{
				fore.messages[i].restore(f.foreMessageLayers[i]);
				back.messages[i].restore(f.backMessageLayers[i]);
			}
		}

		if(clear)
		{
			for(var i = 0; i < numMessageLayers; i++)
			{
				fore.messages[i].clear();
				back.messages[i].clear();
			}
			if(historyLayer.storeState)
			{
				historyLayer.load(f.historyData);
			}
			else
			{
				if(historyWriteEnabled)
				{
					if(historyLayer.everypage)
						historyLayer.repage();
					else
						historyLayer.reline(), historyLayer.reline();
				}
				historyLayer.clearAction();
			}
		}

		// 前景レイヤ
		allocateCharacterLayers(numCharacterLayers);
		if(backlay)
		{
			for(var i = 0; i < numCharacterLayers; i++)
			{
				back.layers[i].restore(f.foreCharacterLayers[i]);
			}
		}
		else
		{
			for(var i = 0; i < numCharacterLayers; i++)
			{
				fore.layers[i].restore(f.foreCharacterLayers[i]);
				back.layers[i].restore(f.backCharacterLayers[i]);
			}
		}

		// quake vB
		restoreQuake();

		// bgm
		if(elm === void || elm.bgm === void || +elm.bgm)
		{
			bgm.restore(f.bgm);
		}

		// 抗音
		if(elm === void || elm.se === void || +elm.se)
		{
			for(var i = 0; i<numSEBuffers; i++)
			{
				se[i].restore(f.se[i]);
			}
		}

		// ウィンドウキャプション
		caption = f.caption;
		System.title = caption;

		// current のO定し直し
		current = (currentPage?back:fore).messages[currentNum];

		// 右クリックメニュ`名
		if(typeof this.rightClickMenuItem != "undefined")
			rightClickMenuItem.caption = rightClickCurrentMenuName;

		// restoreHook
		forEachEventHook('onRestore',
			function(handler, f) { handler(f.flags, f.clear, f.options); } incontextof this,
			%[flags:f, clear:clear, options:elm]);

	}

	function restoreFlags()
	{
		// pcflags, pflags から情螭蛘iみ出す

		// ロ`ドr、ム`ビ`のピリオドイベント情螭颔リアする
		purgeMoviePeriod();

		// スナップショットの破
		freeSnapshot();

		// トランジション、自右婴瓮Ｖ
		stopAllTransitions();
		stopAllMoves();

		// クリック待ち号をLす
		hideClickGlyphs();

		// メッセ`ジ履sをLす
		hideHistory();

		// スキップのキャンセル
		cancelSkip();

		// pflags -> flags
		(Dictionary.assignStruct incontextof flags)(pflags);

		// 莨芾黹vB
		storeLabelPassed = true;
		nextRecordHistory = false;
		stablePosibility = false;

		// コンダクタ
		currentRecordName = "";
		mainConductor.restore(pcflags.mainConductor);
		extraConductor.clear();
		setConductorToMain();

		// iみzみ
		internalRestoreFlags(pcflags);

		// メニュ`vB
		setMenuAccessibleAll();

		// g行_始
		processGo();
	}

	function clearVariables()
	{
		// ゲ`ム涫のクリア
		(Dictionary.clear incontextof flags)();
	}

	//--------------------------------------------------------- 通^h管理 --

	function pushHistoryOfStore()
	{
		// 通^hを行う
		// pflags, pcflags に情螭蚋窦{した後に呼ぶこと

		if(nextRecordHistory)
		{
			if(stablePosibility)
			{
				// stablePosibility が false の龊悉稀
				// そこのラベルで通^hを行っても
				// そこよりも前にるすべがないので通^hをしない

				// 辞配列を作成
				var dic = %[];

				// user と core をh
				dic.user = %[];
				(Dictionary.assignStruct incontextof dic.user)(pflags);
				dic.core = %[];
				(Dictionary.assignStruct incontextof dic.core)(pcflags);

				// dic を historyOfStore の先^に啡
				historyOfStore.insert(0, dic);

				// はみ出た分を削除
				if(historyOfStore.count > maxHistoryOfStore)
					historyOfStore.count = maxHistoryOfStore;
			}

			nextRecordHistory = false;
		}
	}

	function setToRecordHistory()
	{
		// 次の「保存可能なラベル」通^rに
		// 通^hを行うようにO定する
		// ( ただし、そのときにhされるのは、F在の状B )
		nextRecordHistory = true;
	}

	function isHistoryOfStoreAlive()
	{
		// 通^hが利用可能かどうかを返す
		return historyOfStore.count;
	}

	function goBackHistory(ask = true)
	{
		// 通^hをたどり、る

		if(!isHistoryOfStoreAlive())
			return false;

		var result;
		if(ask)
		{
			var prompt = "「"+ historyOfStore[0].core.currentPageName + "」までりますか?";
			result = askYesNo(prompt);
		}
		else
		{
			result = true;
		}

		if(result)
		{
			// user と core を pflags, pcflags にす
			(Dictionary.assignStruct incontextof pflags)(historyOfStore[0].user);
			(Dictionary.assignStruct incontextof pcflags)(historyOfStore[0].core);

			// hの先^を削除する
			historyOfStore.erase(0);

			// デ`タを元に、荬颏郡嗓幼鳏颏工
			restoreFlags();

			return true;
		}
		return false;
	}

	//--------------------------------------------------------------- 莨芾 --

	function createBookMarkSubMenus()
	{
		// 「荬颏郡嗓搿埂荬颏悉丹唷挂韵陇衰单芝幞衰濠`目を追加
		if(freeSaveDataMode) return; // フリ`セ`ブモ`ドではなにもしない
		if(typeof this.storeMenu !== "undefined" && storeMenu.visible)
		{
			for(var i = 0; i<numBookMarks; i++)
			{
				var item;
				storeMenu.add(item = new KAGMenuItem(this, string i, 0, onBookMarkStore,
					false));
				item.bmNum = i;
				item.orgEnabled = false;
			}
		}
		if(typeof this.restoreMenu !== "undefined" && restoreMenu.visible)
		{
			for(var i = 0; i<numBookMarks; i++)
			{
				var item;
				restoreMenu.add(item = new KAGMenuItem(this, string i, 0, onBookMarkRestore,
					false));
				item.bmNum = i;
				item.orgEnabled = false;
			}
		}
	}

	function setBookMarkMenuCaptions()
	{
		// 「荬颏郡嗓搿埂荬颏悉丹唷挂韵陇违单芝幞衰濠`に
		// キャプションをO定

		// 荬蛐む
		if(typeof this.storeMenu !== "undefined")
		{
			var children = storeMenu.children;
			for(var i = children.count - 1; i >= 0; i--)
			{
				if(bookMarkDates[i] != '') // 空文字列の龊悉荬ないということ
				{
					// 荬存在する
					var caption;
					if(showBookMarkDate) caption = bookMarkDates[i] + " ";
					caption += bookMarkNames[i];
					var item = children[i];
					item.caption = caption;
					item.enabled = false;
					item.orgEnabled = !bookMarkProtectedStates[i];
				}
				else
				{
					// 荬存在しない
					var item = children[i];
					item.caption = "(未O定)";
					item.enabled = false;
					item.orgEnabled = !bookMarkProtectedStates[i];
				}
			}
		}

		// 荬颏郡嗓
		if(typeof this.restoreMenu !== "undefined")
		{
			var children = restoreMenu.children;
			for(var i = children.count - 1; i >= 0; i--)
			{
				if(bookMarkDates[i] != '') // 空文字列の龊悉荬ないということ
				{
					// 荬存在する
					var caption;
					if(showBookMarkDate) caption = bookMarkDates[i] + " ";
					caption += bookMarkNames[i];
					var item = restoreMenu.children[i];
					item.caption = caption;
					item.enabled = false;
					item.orgEnabled = true;
				}
				else
				{
					var item = restoreMenu.children[i];
					item.caption = "(未O定)";
					item.enabled = false;
					item.orgEnabled = false;
				}
			}
		}
		setMenuAccessibleAll();
	}

	function setBookMarkProtectedState(num, s)
	{
		// n 番の荬伪ＷoフラグをO定する
		// s = true ならば荬きzみ保oをする
		bookMarkProtectedStates[num] = s;
		setBookMarkMenuCaptions();
	}

	function onBookMarkStore(sender)
	{
		// 荬颏悉丹啷幞衰濠`がxkされた
//		if(!sender.parent.accessEnabled) return;
		saveBookMarkWithAsk(sender.bmNum);
	}

	function onBookMarkRestore(sender)
	{
		// 荬颏郡嗓毳幞衰濠`がxkされた
//		if(!sender.parent.accessEnabled) return;
		loadBookMarkWithAsk(sender.bmNum);
	}

	function getBookMarkPageName(num)
	{
		// 莘号 num のブックマ`ク名を得る
		if(bookMarkDates[num] != '') // 空文字列の龊悉荬ないということ
			return bookMarkNames[num];
		return "(未O定)";
	}

	function getBookMarkDate(num)
	{
		// 莘号 num の日付を得る
		return bookMarkDates[num];
	}

	function getBookMarkFileNameAtNum(num)
	{
		if(num >= 999) // 999 番以降は特殊なデ`タに用いるので
			return saveDataLocation + "/" + dataName + num + ".ksd";
		else
			return saveDataLocation + "/" + dataName + num + (saveThumbnail?".bmp":".kdt");
	}

	function lockSnapshot()
	{
		// スナップショットをロックする
		// 初めてスナップショットがロックされたr点での画面を保存する
		if(snapshotLockCount == 0)
		{
			if(snapshotLayer === void)
				snapshotLayer = new Layer(this, primaryLayer);
			snapshotLayer.setImageSize(scWidth, scHeight);
			snapshotLayer.face = dfAlpha;
			snapshotLayer.piledCopy(0, 0, kag.fore.base, 0, 0, scWidth, scHeight);
		}
		snapshotLockCount ++;
	}

	function unlockSnapshot()
	{
		// スナップショットのロックを解除する
		if(snapshotLockCount == 0)
			throw new Exception("snapshotLockCount がアンダ`フロ`しました");
		snapshotLockCount --;
		if(snapshotLockCount == 0)
		{
			if(snapshotLayer !== void)
				invalidate snapshotLayer, snapshotLayer = void;
		}
	}

	function calcThumbnailSize()
	{
		// サムネイルのサイズを算する
		// 横幅は 133 に
		var ratio = scHeight / scWidth;
		var w = thumbnailWidth;
		var h = (int)(w * ratio);

		// サムネイル用ビットマップのサイズを算
		// サムネイル用画像は 256 色 BMP または 24bit フルカラ` BMP
		var size;
		if (thumbnailDepth == 8)
		  size = ((((w - 1) >> 2) + 1) << 2) * h + 1024 + 54;
		else
		  size = (((w * 3 + 3) >> 2) << 2) * h + 54;

		return %[width : w, height : h, size : size];
	}

	function freeSnapshot()
	{
		// スナップショットを制的に破し、snapshotLockCount を 0 にO定する
		snapshotLockCount = 0;
		if(snapshotLayer !== void)
			invalidate snapshotLayer, snapshotLayer = void;
	}

	function saveBookMarkToFile(fn, savehist = true)
	{
		// ファイル fn に荬虮４妞工
		if(readOnlyMode) return false;
		pcflags.storeTime = (new Date()).getTime(); // 日付を保存

		// セ`ブデ`タをまとめる
		var data = %[];
		data.id = saveDataID;
		data.core = pcflags;
		data.user = pflags;
		if(savehist) data.history = historyOfStore;

		if(saveThumbnail)
		{
			// サムネイルを保存
			lockSnapshot();
			try
			{
				// サムネイルのサイズまでs小
				var size = calcThumbnailSize();
				var tmp = new Layer(this, primaryLayer);
				try
				{
					tmp.setImageSize(size.width, size.height);
					tmp.face = dfAlpha;
					tmp.stretchCopy(0, 0, size.width, size.height, snapshotLayer,
						0, 0, snapshotLayer.imageWidth, snapshotLayer.imageHeight, stLinear);
					/*
					// サムネイル画像をセピア{にして保存する龊悉膝偿幞螗去ウトを解除
					tmp.doGrayScale();
					tmp.adjustGamma(
									1.3, 0, 255,  // R gamma, floor, ceil
									1.0, 0, 255,  // G gamma, floor, ceil
									0.8, 0, 255); // B gamma, floor, ceil
					*/
					try
					{
						// サムネイルを保存
						tmp.saveLayerImage(fn, "bmp" + thumbnailDepth);

						// デ`タを保存
						var mode = saveDataMode;
						mode += "o" + size.size; // モ`ド文字列に きzみオフセットを指定
						(Dictionary.saveStruct incontextof data)(fn, mode);
					}
					catch(e)
					{
						invalidate tmp;
						unlockSnapshot();
						System.inform("ファイルに保存できません (ファイルを_けないか、"
							"きzみ禁止です)");
						return false;
					}
				}
				catch(e)
				{
					invalidate tmp;
					throw e;
				}
				invalidate tmp;
			}
			catch(e)
			{
				unlockSnapshot();
				throw e;
			}
			unlockSnapshot();
		}
		else
		{
			// 通常のファイルに保存
			try
			{
				(Dictionary.saveStruct incontextof data)(fn, saveDataMode);
			}
			catch(e)
			{
				System.inform("ファイルに保存できません (ファイルを_けないか、"
					"きzみ禁止です)");
				return false;
			}
		}

		return true;
	}

	function saveBookMark(num, savehist = true)
	{
		// 莘号 num に荬虮４妞工
		if(readOnlyMode) return false;
		if(bookMarkProtectedStates[num]) return false;

		var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);
		if(ret)
		{
			// メニュ` / bookMarkNames / bookMarkDates を更新
			getBookMarkInfoFromData(pcflags, num);
		}
		return ret;
	}

	function getBookMarkInfoFromData(dic, num)
	{
		// 辞配列 dic から荬违讴`ジ名と日付をiみ出し、
		// bookMarkDates[num] や bookMarkNames[num] にO定する
		if(num < numBookMarks)
		{
			bookMarkNames[num] = dic.currentPageName;
			var date = new Date();
			date.setTime(dic.storeTime);
			date = "%04d/%02d/%02d %02d:%02d".sprintf(
				date.getYear(), date.getMonth() + 1, date.getDate(),
				date.getHours(), date.getMinutes() );
			bookMarkDates[num] = date;
			setBookMarkMenuCaptions();
			saveSystemVariables();
		}
	}

	function loadBookMarkFromFile(fn, loaduser = true)
	{
		// ファイル fn から荬蛘iみzむ
		// loaduser が false のrは user をiみzまない
		try
		{
			if(!Storages.isExistentStorage(fn)) return false; //ファイルがない

			var data;

			var modestr;

			if(saveThumbnail)
			{
				// 指定オフセットからデ`タをiみzむ
				modestr += "o" + calcThumbnailSize().size;
			}

			data = Scripts.evalStorage(fn, modestr);

			if(data.id != saveDataID)
			{
				System.inform("他のシステムのデ`タをiみzもうとしました", "エラ`");
				return false;
			}

			pcflags = data.core;
			pcflags = %[] if pcflags === void;
			if(loaduser)
			{
				pflags = data.user;
				pflags = %[] if pflags === void;
			}
			else
			{
				(Dictionary.assignStruct incontextof pflags)(flags);
			}
			historyOfStore = data.history;
			historyOfStore = [] if historyOfStore === void;
		}
		catch(e)
		{
			System.inform("荬蛘iみzめないか、荬"
				"菠欷皮い毪、あるいは他の形式の荪签`タ"
				"です(" + e.message + ")", "エラ`");
			return false;
		}

		restoreFlags();
		return true;
	}

	function loadBookMark(num, loaduser = true)
	{
		// 莘号 num からデ`タをiみ出す
		return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);
	}

	function saveBookMarkWithAsk(num)
	{
		// 莘号 num に荬蛟O定する
		// そのとき、O定するかどうかをたずねる
		if(readOnlyMode) return false;
		if(bookMarkProtectedStates[num]) return false;
		var prompt = " ";
		if(num < numBookMarks) prompt += (num + 1);
		if(bookMarkDates[num] != "") // bookMarkDates が空文字の龊悉荬洗嬖冥筏胜
			prompt += "「" + bookMarkNames[num] + "」";
		prompt += "に「"+ pcflags.currentPageName + "」をはさみますか?";
		var result = askYesNo(prompt);
		if(result) return saveBookMark(num);
		return false;
	}

	function loadBookMarkWithAsk(num)
	{
		// 莘号 num から荬蛘iみ出す
		// そのとき、iみ出すかどうかをたずねる
		if(num < numBookMarks && bookMarkDates[num] == "") // bookMarkDates が空文字の龊悉荬洗嬖冥筏胜
			return false;
		var prompt = " ";
		if(num < numBookMarks) prompt += (num + 1);
		prompt += "「"+ bookMarkNames[num] + "」をたどりますか?";
		var result = askYesNo(prompt);
		if(result) return loadBookMark(num);
		return false;
	}

	function saveBookMarkToFileWithAsk()
	{
		// 任意のファイルに荬虮４妞工
		// currentPageName をファイル名としてm合するように
		// 湫韦工
		var invalid = "\\/:,;*?\"<>!.";
		var valid = "￥／：，；＊？”＜＞！．";

		var initialname = saveDataLocation + "/";
		var through = false;
		var orgname = currentPageName;

		if(lastSaveDataNameGlobal != "")
		{
			try
			{
				initialname = Storages.extractStoragePath(lastSaveDataNameGlobal);
			}
			catch(e)
			{
				initialname = saveDataLocation + "/";
			}
		}

		if(orgname == "")
		{
			// 荬我出しがないので
			if(lastSaveDataName == "")
				orgname = System.title; // System.title を代わりに使う
			else
				initialname = lastSaveDataName, through = true;
		}

		if(!through)
		{
			var length = orgname.length;
			for(var i = 0; i < length; i++)
			{
				var ch = orgname[i];
					var ind = invalid.indexOf(ch);
				if(ind != -1)
					initialname += valid[ind];
				else if(#ch >= 32)
					initialname += ch;
			}
		}

		// 保存するファイル名を得る
		var selectdata = %[
			title:"荬颏悉丹",
			filter: [saveThumbnail ?
					"サムネイル画像付き荪签`タ(*.bmp)|*.bmp" :
					"荪签`タ(*.kdt)|*.kdt"],
			filterIndex : 1,
			name : initialname,
			initialDir : "",
			defaultExt : saveThumbnail?"bmp":"kdt",
			save : true,
		];
		if(Storages.selectFile(selectdata))
		{
			// 保存
			saveBookMarkToFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);
			lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);
		}
	}

	function loadBookMarkFromFileWithAsk()
	{
		// 任意のファイルから荬蛘iみzむ
		var initialdir = "";
		if(lastSaveDataNameGlobal == "")
			initialdir = saveDataLocation + "/";

		var selectdata = %[
			title:"荬颏郡嗓",
			filter: [saveThumbnail ?
					"サムネイル画像付き荪签`タ(*.bmp)|*.bmp" :
					"荪签`タ(*.kdt)|*.kdt"],
			filterIndex : 1,
			name : lastSaveDataNameGlobal,
			initialDir : initialdir,
			defaultExt : saveThumbnail?"bmp":"kdt",
			save : false,
		];
		if(Storages.selectFile(selectdata))
		{
			loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);
			lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);
		}
	}


	function copyBookMark(from, to)
	{
		// 莘号 from から莘号 to に荬颔偿冤`する
		if(readOnlyMode) return false;
		if(bookMarkProtectedStates[to]) return;

		var fn = getBookMarkFileNameAtNum(from);

		if(!Storages.isExistentStorage(fn)) return; //ファイルがない

		var data = Scripts.evalStorage(fn);

		fn = getBookMarkFileNameAtNum(to);

		(Dictionary.saveStruct incontextof data)(fn, saveDataMode);
		getBookMarkInfoFromData(data.core, to);
	}

	function eraseBookMark(num)
	{
		// 荬蛳す
		// num < numBookMarks のrにしか幼鳏筏胜い瑜Δ摔胜盲郡韦亲⒁
		if(num < numBookMarks)
		{
			if(!bookMarkProtectedStates[num])
			{
				bookMarkDates[num] = "";
				setBookMarkMenuCaptions();
			}
		}
	}

	function tempDisableStore(elm)
	{
		// 荬蛞r的に保存不可能にする
		storeEnabled = true;
		if(elm.store === void)
			storeLabelPassed = false;
		else
			storeLabelPassed = !(+elm.store);
		if(elm.restore == void)
			restoreEnabled = true;
		else
			restoreEnabled = !(+elm.restore);
		setMenuAccessibleAll();
	}

	function setStoreEnabled(enabled)
	{
		// 荪幞衰濠`の有/o郡卧O定
		storeEnabled = enabled;
		restoreEnabled = enabled;
		setMenuAccessibleAll();
	}

	function setStartAnchorEnabled(enabled)
	{
		// 「最初にる」の有/o郡卧O定
		startAnchorEnabled = enabled;
		if(enabled) saveBookMark(999, false); // 999 番に保存
		setMenuAccessibleAll();
	}

	function goToStart()
	{
		// 最初にる
		if(!startAnchorEnabled) return;
		loadBookMark(999, false); // 荬蛘iみzむ
	}

	function goToStartWithAsk()
	{
		// 最初にる(_Jあり)
		var result = askYesNo("最初にります。よろしいですか ?");
		if(result) goToStart();
	}

	function tempSave(num)
	{
		// tempBookMarks[num] にF在の状Bを保存する
		tempBookMarks[num] = %[];
		internalStoreFlags(tempBookMarks[num]);
	}

	function tempLoad(num, elm)
	{
		// tempBookMarks[num] から状Bをiみzむ
		internalRestoreFlags(tempBookMarks[num], false, elm);
	}

	function restoreBookMark(num, ask = true)
	{
		// KAG 2.x 互Q用
		if(ask)
			return loadBookMarkWithAsk(num);
		else
			return loadBookMark(num);
	}

	function storeBookMark(num, ask = true)
	{
		// KAG 2.x 互Q用
		if(ask)
			return saveBookMarkWithAsk(num);
		else
			return saveBookMark(num);
	}

	//------------------------------------------------- 未i/既i/ラベルh --

	function setRecordLabel(storage, label)
	{
		// F在のラベルをO定する
		if(autoRecordPageShowing)
		{
			if(label != '')
			{
				if(label[0] == '*') label = label.substring(1);
				if(label[1] == '-') return; // ロ`カルラベル
			}
			currentRecordName = 'trail_' + Storages.chopStorageExt(
				Storages.extractStorageName(storage)) + '_' + label;
		}
	}

	function incRecordLabel(count)
	{
		// sflags[currentRecordName]++
		if(autoRecordPageShowing)
		{
			if(currentRecordName != "")
			{
				if(count)
				{
					if(sflags[currentRecordName] === void)
						sflags[currentRecordName] = 0;
					sflags[currentRecordName]++;
				}
				currentRecordName = "";
			}
		}
	}

	//------------------------------------------- システム全体にvSするもの --

	function setTitle(title)
	{
		// タイトルをO定
		if(isMain) System.title = title;
		caption = title;
	}

	function setCursor(elm)
	{
		// マウスカ`ソルのO定
		var conv = function(variable, value)
		{
			if(value !== void)
			{
				if(!(typeof value == "String" &&
					(value.indexOf('.cur')!=-1 || value.indexOf('.ani')!=-1) ))
						value = +value;
				this[variable] = value;
			}
		} incontextof this;

		conv('cursorDefault', elm['default']); 
		conv('cursorPointed', elm.pointed);
		conv('cursorWaitingClick', elm.click);
		conv('cursorDraggable', elm.draggable);
		fore.base.setDefaultCursor(cursorDefault);
		back.base.setDefaultCursor(cursorDefault);
	}

	//---------------------------------------------------- トリガ管理(TJS用) --

	function waitTrigger(elm)
	{
		// elm.name で示されたトリガを待つ
		if((elm.canskip !== void && +elm.canskip) && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ幼髦
				if(elm.onskip !== void) Scripts.eval(elm.onskip);
				return 0; // すぐに返る
			}
			conductor.wait(%[
				click : function(arg)
				{
					if(arg !== void) Scripts.eval(arg);
				} incontextof this,
				click_arg : elm.onskip,
				elm.name => function
				{
				} incontextof this
				]);
		}
		else
		{
			conductor.wait(%[
				elm.name => function
				{
				} incontextof this
				]);
		}
		return -2;
	}

	function trigger(name)
	{
		// name で示したトリガをk婴工
		conductor.trigger(name);
	}

	//------------------------------------------------------- メッセ`ジ履s --

	function showHistory()
	{
		// メッセ`ジ履sレイヤを表示する
		historyLayer.parent = fore.base; // メッセ`ジ履sレイヤのHも再O定
		historyLayer.absolute = 2000000;
		historyLayer.dispInit();
		historyShowing = true;
		if(typeof this.showHistoryMenuItem != "undefined")
			showHistoryMenuItem.checked = true;
		setMenuAccessibleAll();
	}

	function hideHistory()
	{
		// メッセ`ジ履sレイヤを非表示にする
		historyLayer.dispUninit();
		historyShowing = false;
		if(typeof this.showHistoryMenuItem != "undefined")
			showHistoryMenuItem.checked = false;
		setMenuAccessibleAll();
		lastHistoryHiddenTick = System.getTickCount();
		conductor.trigger('history'); // 'history' を送る
	}

	function setHistoryOptions(elm)
	{
		// elm からメッセ`ジ履sレイヤのオプションをO定する
		historyWriteEnabled = +elm.output if elm.output !== void;
		historyEnabled = +elm.enabled if elm.enabled !== void;
		if(elm.enabled !== void && !historyEnabled)
			historyLayer.clearAction();
		historyLayer.setOptions(elm); // その他のオプション
		setMenuAccessibleAll();
	}

	function showHistoryByScenario(elm)
	{
		// メッセ`ジ履sをシナリオ中から表示させる
		showHistory();
		conductor.wait(%[ // コンダクタを待ちに
			history : function
			{
				// やることなし
			} incontextof this
			]);
		return -2; // break
	}

	//-------------------------------------------------------------- process --

	function process(file, label, countpage = true, immediate = false)
	{
		// 指定ファイル、指定ラベルからg行を_始する
		if(!usingExtraConductor) incRecordLabel(countpage);
		setUserSpeed();

		if(file != '')
		{
			// ファイルをiみzみ
			conductor.loadScenario(file);
		}

		if(label != '')
		{
			// ラベルに移婴工
			conductor.goToLabel(label);
		}

		if(isFirstProcess)
		{
			storeFlags(); // 一番最初の状Bをストア
			isFirstProcess = false;
		}


		dm("I理を_始します");
		inSleep = false;
		notifyRun();
		if(conductor.status != conductor.mRun) conductor.run(immediate); // g行_始
	}

	function processGo()
	{
		// コンダクタをF在位置からg行_始させる
		dm("I理を_始します");
		inSleep = false;
		notifyRun();
		conductor.run(false); // g行_始
	}

	function processCall(file, label)
	{
		// 指定ファイル、指定ラベルを呼ぶ
		// incRecordLabel(); は呼ばないので注意

		if(file != '')
		{
			// ファイルをiみzみ
			conductor.loadScenario(file);
		}

		inSleep = false;
		notifyRun();
		conductor.callLabel(label); // g行_始
		dm("I理を_始します");
		if(conductor.status != conductor.mRun) conductor.run();
	}

	//------------------------------------------------- コンダクタのイベント --

	function onConductorScenarioLoad(name)
	{
		// コンダクタが新しいシナリオファイルをiみzむ前によばれる。
		// name はiみzもうとしたシナリオファイル。
		// りに文字列を返すと、それをシナリオとして
		// ファイルの代わりに使うようになるので、ここにフィルタをくこ
		// とができる。
		// true を返すと通常のシナリオファイルiみzみとなる。
		return true;
	}


	function onConductorScenarioLoaded(name)
	{
		// コンダクタが新しいシナリオファイルをiみzんだ
//		if(!usingExtraConductor) incRecordLabel(true);
		return true;
	}

	function onConductorLabel(label, page)
	{
		// コンダクタがラベルを通^した
		if(!usingExtraConductor)
		{
			incRecordLabel(true);
			setRecordLabel(conductor.curStorage, label);
		}
		setUserSpeed();
		if(!usingExtraConductor)
		{
			if(!getCurrentRead() && skipMode != 4)
				cancelSkip(); // 未iなのでスキップを停止
			currentLabel = label;
		}
		if(page !== void && page !== '')
		{
			if(page[0] == '&') page = Scripts.eval((page.substring(1)));
			currentPageName = page;
		}
		if(page !== void)
		{
			pushHistoryOfStore();
			stablePosibility = false;
			dm(conductor.curStorage + " : ラベル/ペ`ジ : " + label + "/" + currentPageName);
			if(usingExtraConductor) throw new Exception("右クリックサブル`チン内/extraCondutor"
				"サブル`チン内では保存可能なラベルを述できません");
			storeFlags(), storeLabelPassed = true, setMenuAccessibleAll();
			if(recordHistoryOfStore == 1) // 1 : 保存可能なラベルごと
				setToRecordHistory();
		}
		return true;
	}

	function onConductorJump(elm)
	{
		// コンダクタで jump タグをI理するとき
		if(!usingExtraConductor) incRecordLabel(elm.countpage === void || +elm.countpage);
		return true;
	}

	function onConductorCall(elm)
	{
		// コンダクタが call タグをI理するとき
		if(!usingExtraConductor) incRecordLabel(elm.countpage !== void && +elm.countpage);
		return true;
	}

	function onConductorReturn(elm)
	{
		// コンダクタが return タグをI理するとき
		if(!usingExtraConductor) incRecordLabel(elm.countpage === void || +elm.countpage);
		if(conductor === extraConductor)
		{
			// extraConductor サブル`チン用のコンダクタから呼ばれている
			if(conductor.callStackDepth == 1)
			{
				// つまり、最Kの return がg行されたと言うこと
				dm("extraConductor サブル`チンからります ...");
				var run;
				if(elm.storage !== void || elm.target !== void) run = true; else run = false;
				returnExtraConductor(run);
				if(elm.storage !== void) conductor.loadScenario(elm.storage);
				if(elm.target !== void) conductor.goToLabel(elm.target);
				setRecordLabel(conductor.curStorage, currentLabel = conductor.curLabel);
				if(run)
				{
					notifyRun();
					conductor.run();
				}
				isLeavePeriodEvent = false;
				if(elm.storage !== void || elm.target !== void)
				{	// returnで元の位置以外にるrはピリオドイベントをクリアする。
					holdPeriodEventQueue.clear();
					isWaitPeriodEvent = false;
				}
				if( isWaitPeriodEvent == true )
				{	// [wp]でピリオドイベント待ちをしているrのみ、トリガ`する
					fireMoviePeriodFromQueue();
				}
				return false; // return はg行しない
			}
		}
		return true;
	}
	function purgeMoviePeriod()
	{
		isLeavePeriodEvent = false;
		holdPeriodEventQueue.clear();
		isWaitPeriodEvent = false;
		waitedPeriodEventStorageName = void;
	}
	function fireMoviePeriodFromQueue()
	{
		var retVal = false;
		if( holdPeriodEventQueue.count > 0 )
		{
			if( waitedPeriodEventStorageName == conductor.curStorage && conductor == mainConductor )
			{
				for( var i = 0; i < holdPeriodEventQueue.count; i++ )
				{
					conductor.trigger( holdPeriodEventQueue[i] );
					retVal = true;
				}
			}
			holdPeriodEventQueue.clear();
		}
		return retVal;
	}

	function onConductorAfterReturn()
	{
		// コンダクタが return タグをg行した後
		if(!usingExtraConductor)
		{
			setRecordLabel(conductor.curStorage, currentLabel = conductor.curLabel);
		}
		setUserSpeed();
		if(!usingExtraConductor)
		{
			if(!getCurrentRead() && skipMode != 4)
				cancelSkip(); // 未iなのでスキップを停止
		}
	}


	function onConductorScript(script, scriptname, lineofs)
	{
		// iscript タグ
		try
		{
			Scripts.exec(script, scriptname, lineofs);
		}
		catch(e)
		{
			throw new Exception(scriptname + " の 行 " + lineofs + " から始まる"
				" iscript ブロックでエラ`がk生しました。"
				"\n( はコンソ`ルを参照してください )\n" + e.message);
		}
		return true;
	}

	function onConductorUnknownTag(tagname, elm)
	{
		// 不明なタグがあった龊
		throw new Exception("タグ/マクロ \"" + tagname + "\" は存在しません");
		return 0; // このりは、各タグハンドラが返す物とおなじ
	}

	//----------------------------------------------------------- stable/run --

	function notifyStable()
	{
		// システムが安定(クリック待ち/停止)したときに、ハンドラを呼ぶ
		if(!inStable)
		{
			inStable = true;
			var handlers = stableHandlers;
			for(var i = handlers.count-1; i>=0; i--)
				handlers[i]();

			// stableHook
			forEachEventHook('onStableStateChanged',
				function(handler, f) { handler(f.stable); } incontextof this,
				%[stable:true]);
		}
	}

	function notifyRun()
	{
		// システムが走り始めたときに、ハンドラを呼ぶ
		if(inStable)
		{
			inStable = false;
			var handlers = runHandlers;
			for(var i = handlers.count-1; i>=0; i--)
				handlers[i]();

			// runHook
			forEachEventHook('onStableStateChanged',
				function(handler, f) { handler(f.stable); } incontextof this,
				%[stable:false]);

			if(autoMode) hideMouseCursor();
		}
	}

	function defaultStableHandler()
	{
		// デフォルトの stable ハンドラ
		setMenuAccessibleAll();
	}

	function defaultRunHandler()
	{
		// デフォルトの run ハンドラ
		hideHistory();
		hideClickGlyphs();
		showMessageLayerByUser();
		setMenuAccessibleAll();
	}

	//----------------------------------------------------------- 文字列入力 --

	var inputTemp;
	function inputString(elm)
	{
		// 文字列を入力する
		var name = elm.name;
		var initial = Scripts.eval(name);
		var res = System.inputString(elm.title, elm.prompt, initial);
		if(res !== void)
		{
			// name に res を代入する
			inputTemp = res;
			Scripts.eval(("(" + name + ") = kag.inputTemp"));
		}
	}

	//-------------------------------------------------- extraConductor I理 --

	function callExtraConductor(storage, label, onreturn)
	{
		// extraConductor を使ってサブル`チンを呼び出す
		onExtraConductorReturn = onreturn;
		inSleepBeforeExtraConductor = inSleep; // inSleep 保存
		storeMessageLayerSelProcessLock(); // メッセ`ジレイヤの storeSelProcessLock を呼ぶ
		conductor = extraConductor; // コンダクタを切り替える
		(Dictionary.assign incontextof extraConductor.macros)(mainConductor.macros);
			// マクロはコピ`
		usingExtraConductor = true;
		if(storage == '')
		{
			// ストレ`ジ指定がないのでF在のストレ`ジをiみzませる
			storage = mainConductor.curStorage;
		}

		// 呼び出す
		conductor.clearCallStack();
		processCall(storage, label);
	}

	function returnExtraConductor(run)
	{
		// extraConductor のサブル`チンからる
		// run が true の龊悉 待C状Bのは行わない

		conductor.sleep(); // 停止
		conductor.interrupt();
			// interrupt は コンダクタのイベント内でコンダクタのg行を
			// 停止させるためのメソッド
		conductor = mainConductor; // コンダクタを切り替え
		(Dictionary.assign incontextof mainConductor.macros)(extraConductor.macros);
			// マクロはコピ`
		usingExtraConductor = false;
		if(!run)
		{	restoreClickGlyphState(); // クリック待ち号の
			inSleep = inSleepBeforeExtraConductor; // inSleep 
			notifyStable();
		}
		restoreMessageLayerSelProcessLock(); // メッセ`ジレイヤの restoreSelProcessLock を呼ぶ
		setMenuAccessibleAll();
		cancelSkip();

		if(onExtraConductorReturn !== void) onExtraConductorReturn();
	}

	//------------------------------------------------------- 右クリックI理 --

	function setRightClickOptions(elm)
	{
		// 右クリックのオプションをO定する
		rightClickEnabled = +elm.enabled if elm.enabled !== void;
		if(elm.call !== void)
		{
			rightClickCall = +elm.call;
			if(rightClickCall) rightClickJump = false;
		}
		if(elm.jump !== void)
		{
			rightClickJump = +elm.jump;
			if(rightClickJump) rightClickCall = false;
		}
		rightClickTarget = elm.target if elm.target !== void;
		rightClickStorage = elm.storage if elm.storage !== void;
		if(elm.name !== void)
		{
			if(typeof this.rightClickMenuItem != "undefined")
			{
				rightClickName = elm.name;
				if(rightClickName == "default")
					rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickDefaultName;
				else
					rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickName;
			}
		}
	}

	function callRightClickSubRoutine()
	{
		isLeavePeriodEvent = true;

		// 右クリックサブル`チンを呼ぶ
		if(typeof this.rightClickMenuItem != "undefined")
		{
			rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickDefaultName;
		}

		callExtraConductor(rightClickStorage, rightClickTarget, restoreFromRightClick);

		lockMessageLayerSelProcess(); // xk肢ロック
	}

	function restoreFromRightClick()
	{
		// 右クリックサブル`チンからiけるときに呼ばれる
		if(typeof this.rightClickMenuItem != "undefined")
		{
			if(rightClickName == "default")
				rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickDefaultName;
			else
				rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickName;
		}
	}

	function setConductorToMain()
	{
		// restore のrに呼ばれ、コンダクタを main に切り替える
		if(usingExtraConductor)
		{
			extraConductor.sleep();
			extraConductor.interrupt();
			conductor= mainConductor;
			usingExtraConductor = false;
		}
	}

	function jumpToRightClickTarget()
	{
		process(rightClickStorage, rightClickTarget);
	}

	function onPrimaryRightClick()
	{
		// プライマリレイヤで右クリックされたときに呼ばれる
		if(!callHook(rightClickHook))
		{
			if(getKeyState(VK_LBUTTON))
			{
				enterAutoMode();
				return;
			}
			if(!rightClickEnabled) return;
			if(inStable)
			{
				if(rightClickJump)
					jumpToRightClickTarget();
				else if(rightClickCall && conductor == mainConductor)
					callRightClickSubRoutine();
				else
					switchMessageLayerHiddenByUser();
			}
			setMenuAccessibleAll();
		}
	}

	//------------------------------------------------------- 前景レイヤI理 --

	function allocateCharacterLayers(num)
	{
		// 前景レイヤ数を num にO定する
		if(fore.layers.count > num)
		{
			// レイヤがpる
			for(var i = num; i<fore.layers.count; i++)
			{
				invalidate fore.layers[i];
				invalidate back.layers[i];
			}
			fore.layers.count = num;
			back.layers.count = num;
		}
		else if(fore.layers.count < num)
		{
			// レイヤがえる
			for(var i = fore.layers.count; i<num; i++)
			{
				fore.layers[i] = new CharacterLayer(this, fore.base, "表前景レイヤ" + i, i);
				back.layers[i] = new CharacterLayer(this, back.base, "Y前景レイヤ" + i, i);
				fore.layers[i].setCompLayer(back.layers[i]);
				back.layers[i].setCompLayer(fore.layers[i]);
			}
			reorderLayers();
		}
		numCharacterLayers = num;
	}

	//------------------------------------------------- メッセ`ジレイヤI理 --

	function allocateMessageLayers(num, setdefaultfont = true)
	{
		// メッセ`ジレイヤ数を num にO定する
		if(fore.messages.count > num)
		{
			// レイヤがpる
			for(var i = num; i<fore.messages.count; i++)
			{
				if(current == fore.messages[i] || current == back.messages[i])
					current = fore.messages[0], currentNum = 0, currentPage = 0;
				invalidate fore.messages[i];
				invalidate back.messages[i];
			}
			fore.messages.count = num;
			back.messages.count = num;
		}
		else if(fore.messages.count < num)
		{
			// レイヤがえる
			for(var i = fore.messages.count; i<num; i++)
			{
				fore.messages[i] = new MessageLayer(this, fore.base, "表メッセ`ジレイヤ" + i, i, true);
				back.messages[i] = new MessageLayer(this, back.base, "Yメッセ`ジレイヤ" + i, i, true);
				fore.messages[i].setCompLayer(back.messages[i]);
				back.messages[i].setCompLayer(fore.messages[i]);
				fore.messages[i].clear();
				back.messages[i].clear();
			}
			reorderLayers();
			if(setdefaultfont) setMessageLayerUserFont();
		}
		numMessageLayers = num;
	}

	function setCurrentMessageLayer(elm)
	{
		// F在のメッセ`ジレイヤをO定
		var page = getMessageLayerPageFromElm(elm);
		var num = getMessageLayerNumberFromElm(elm);
		currentNum = num;
		currentPage = page;
		if(page) current = back.messages[num]; else current = fore.messages[num];
		currentWithBack = +elm.withback if elm.withback !== void;
	}

	function setMessageLayerPosition(elm)
	{
		// F在のメッセ`ジレイヤの位置、属性をO定
		var layer = getMessageLayerObjectFromElm(elm);
		elm.setPosition(elm);
	}

	function clearMessageLayers(resetcurrent)
	{
		// すべてのメッセ`ジレイヤのクリア
		// ct タグから呼ばれる
		// resetcurrent が true の龊悉犀F在のメッセ`ジレイヤを
		// 表0にO定する

		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].clear();
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].clear();
		if(resetcurrent)
		{
			currentNum = 0;
			currentPage = 0;
			current = fore.messages[0];
			currentWithBack = false;
		}
	}

	function lockMessageLayerSelProcess()
	{
		// すべてのメッセ`ジレイヤに xkとprocessを禁止させる
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(true);
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(true);
	}

	function unlockMessageLayerSelProcess()
	{
		// すべてのメッセ`ジレイヤのxkをS可する
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(false);
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(false);
	}

	function setMessageLayerUserFont()
	{
		// すべてのメッセ`ジレイヤの defaultAntialiased と
		// userFace をO定する
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--)
			messages[i].defaultAntialiased = chDefaultAntialiased,
			messages[i].userFace = chDefaultFace;
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--)
			messages[i].defaultAntialiased = chDefaultAntialiased,
			messages[i].userFace = chDefaultFace;
	}

	function storeMessageLayerSelProcessLock()
	{
		// すべてのメッセ`ジレイヤの storeSelProcessLock を呼び出す
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].storeSelProcessLock();
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].storeSelProcessLock();
	}

	function restoreMessageLayerSelProcessLock()
	{
		// すべてのメッセ`ジレイヤの restoreSelProcessLock を呼び出す
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].restoreSelProcessLock();
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].restoreSelProcessLock();
	}

	function setMessageLayerHiddenState(b)
	{
		var layers;
		layers = fore.messages;
		for(var i = layers.count-1; i >= 0; i--) layers[i].setHiddenStateByUser(b);
		layers = fore.layers;
		for(var i = layers.count-1; i >= 0; i--) layers[i].setHiddenStateByUser(b);

		// プラグインを呼ぶ
		forEachEventHook('onMessageHiddenStateChanged',
			function(handler, f) { handler(f.hidden); } incontextof this,
			%[hidden:b]);
	}

	function hideMessageLayerByUser()
	{
		// メッセ`ジレイヤを一r的にLす
		if(messageLayerHiding) return;
		setMessageLayerHiddenState(true);
		if(typeof this.rightClickMenuItem !== "undefined")
			rightClickMenuItem.checked = true;
		messageLayerHiding = true;
		fore.base.cursor = cursorWaitingClick;
		setMenuAccessibleAll();
	}

	function showMessageLayerByUser()
	{
		// 一r的にLされていたメッセ`ジレイヤを元にす
		if(!messageLayerHiding) return;
		setMessageLayerHiddenState(false);
		if(typeof this.rightClickMenuItem !== "undefined")
			rightClickMenuItem.checked = false;
		messageLayerHiding = false;
		conductor.trigger('message'); // 'message' を送る
		if(clickWaiting)
			fore.base.cursor = cursorWaitingClick;
		else
			fore.base.cursor = cursorDefault;
		setMenuAccessibleAll();
	}

	function switchMessageLayerHiddenByUser()
	{
		// メッセ`ジレイヤの非表示/表示を切り替える
		if(messageLayerHiding) showMessageLayerByUser(); else hideMessageLayerByUser();
	}

	function hideMessageLayerByScenario(elm)
	{
		// シナリオからメッセ`ジを一r的にLす
		hideMessageLayerByUser();
		conductor.wait(%[ // コンダクタを待ちに
			message : function
			{
				// やることなし
			} incontextof this
			]);
		return -2; // break
	}

	function selectFont()
	{
		// フォントをxkする
		fore.base.font.face = chDefaultFace;
		fore.base.font.height = -20;
		var flags = fsfSameCharSet | fsfNoVertical | fsfTrueTypeOnly | fsfUseFontFace;
		if(showFixedPitchOnlyInFontSelector) flags |= fsfFixedPitch;
		if(fore.base.font.doUserSelect(flags, "フォントのxk",
			"フォントをxkしてください", "ABCDEFGHIあいうえお胃宇}御"))
		{
			chDefaultFace = fore.base.font.face;
			setMessageLayerUserFont();
		}
	}

	function mapPrerenderedFont(storage)
	{
		// レンダリングgみフォントをF在の操作象のレイヤにxk
		// されているフォントにマッピングする
		current.decideSizeChange();
		current.lineLayer.font.mapPrerenderedFont(storage);
	}

	//------------------------------------------------- レイヤを正しい序に --

	function reorderLayers()
	{
		// レイヤを正しい序にKび替える
		var index = 1000;
		for(var i = 0; i<fore.layers.count; i++)
		{
			fore.layers[i].absolute = index;
			back.layers[i].absolute = index;
			index += 1000;
		}
		index = 1000000;
		for(var i = 0; i<fore.messages.count; i++)
		{
			fore.messages[i].absolute = index;
			back.messages[i].absolute = index;
			index += 1000;
		}

		historyLayer.absolute = 2000000;

	}

	//--------------------------------------------- 属性->レイヤオブジェクト --

	function getLayerFromElm(elm, prefix = '')
	{
		// elm に指定されている page と layer 属性から、当する
		// オブジェクトを返す
		// prefix には、属性名の前につけるプレフィクスを指定する
		var base;
		if(elm[prefix + 'page'] == 'back') base = back; else base = fore;
		var layer = elm[prefix + 'layer'];
		if(layer == 'base') return base.base; // 背景
		if(layer[0] == 'm')
		{
			// message? ( ? = 数 )
			// ここではあまり密にエラ`チェックはしない
			if(layer == 'message') return base.messages[currentNum];
			return base.messages[+layer.substr(7)];
		}
		return base.layers[+layer];
	}

	function getLayerPageFromElm(elm, backlay)
	{
		// getLayerFromElm と似ているが、page 属性まではみない。
		// backlay が true のときはY、false のrは表のレイヤを返す。
		// elm.layer が void のrは背景レイヤをす
		var base = backlay?back:fore;
		var layer = elm.layer;
		if(layer === void || layer == 'base') return base.base; // 背景
		if(layer[0] == 'm')
		{
			if(layer == 'message') return base.messages[currentNum];
			return base.messages[+layer.substr(7)];
		}
		return base.layers[+layer];
	}

	function getMessageLayerPageFromElm(elm)
	{
		// elm から当する表/Y画面のメッセ`ジレイヤ配列を返す
		if(elm.page == 'back') return 1; else return 0;
	}

	function getMessageLayerNumberFromElm(elm)
	{
		// elm の layer 属性の示すメッセ`ジレイヤ番号を返す
		var layer = elm.layer;
		if(layer === void || layer == 'message') return currentNum;
		return +layer.substr(7);
	}

	function getMessageLayerObjectFromElm(elm)
	{
		// elm の layer 属性の示すメッセ`ジレイヤを返す
		var page = elm.page;
		var layer = elm.layer;
		if(page === void && layer === void) return current;
		var base;
		if(page == 'back') base = back; else base = fore;
		if(layer === void || layer == 'message') return base.messages[currentNum];
		return base.messages[+layer.substr(7)];
	}

	function getMessageLayerObjectFromPageAndNumber(page, num)
	{
		return (page?back:fore).messages[num];
	}

	//----------------------------------------------------- レイヤコピ`vB --

	function backupLayer(elm, toback)
	{
		// レイヤの表←→Ygのコピ`を行う
		// toback = true の龊悉媳怼Y、false の龊悉涎Y→表
		if(elm.layer !== void)
		{
			// レイヤ指定がある
			getLayerPageFromElm(elm, toback).assignComp(); // のレイヤの内容をコピ`
		}
		else
		{
			// レイヤ指定がoいので全部のレイヤをコピ`
			var base = toback ? back:fore;
			base.base.assignComp();
			var layers = base.layers, messages = base.messages;
			for(var i = layers.count-1; i >= 0; i--) layers[i].assignComp();
			for(var i = messages.count-1; i >= 0; i--) messages[i].assignComp();

			forEachEventHook('onCopyLayer',
				function(handler, f) { handler(f.toback); } incontextof this,
				%[toback:toback]);
		}
	}

	function copyLayer(elm)
	{
		// elm に兢盲仆Nのレイヤgのコピ`を行う
		var src = getLayerFromElm(elm, 'src');
		var dest = getLayerFromElm(elm, 'dest');
		dest.assign(src);
	}

	//--------------------------------------------------- アニメ`ションvB --

	function onAnimationStopped(name, segment)
	{
		// アニメ`ションが停止した
		conductor.trigger('anim:' + name + ':' + segment);
	}

	function waitAnimation(elm)
	{
		// アニメ`ションの停止をまつ
		var layer = getLayerFromElm(elm);
		var seg = +elm.seg;
		if(!layer.canWaitAnimStop(seg)) return 0; // アニメ`ションの停止を待つ
		conductor.wait(%[
			'anim:' + layer.name + ':' + seg => function
			{
			} incontextof this
			]);
		return -2;
	}

	//--------------------------------------------------- トランジションvB --

	function onLayerTransitionCompleted(layer, dest, src)
	{
		// レイヤでトランジションがK了したときに呼ばれる
		conductor.trigger('trans'); // 'trans' を送る
	}

	function waitTransition(elm)
	{
		// トランジションを待つ
		if(transCount == 0) return 0; // トランジションを待てない
		if((elm.canskip === void || +elm.canskip) && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ幼髦
				stopAllTransitions();
				return 0; // トランジションを停止させてすぐに返る
			}
			conductor.wait(%[
				click : function
				{
					updateBeforeCh = 1;
					stopAllTransitions(); // すべてのトランジションは停止
				} incontextof this,
				trans : function
				{
					updateBeforeCh = 1;
				} incontextof this
				]);
		}
		else
		{
			conductor.wait(%[
				trans : function
				{
					updateBeforeCh = 1;
				} incontextof this
				]);
		}
		return -2;
	}

	function stopAllTransitions()
	{
		// すべてのトランジションを停止させる
		var layers, messages;
		fore.base.stopTransition();
		layers = fore.layers, messages = fore.messages;
		for(var i = layers.count-1; i >= 0; i--) layers[i].stopTransition();
		for(var i = messages.count-1; i >= 0; i--) messages[i].stopTransition();
		back.base.stopTransition();
		layers = back.layers, messages = back.messages;
		for(var i = layers.count-1; i >= 0; i--) layers[i].stopTransition();
		for(var i = messages.count-1; i >= 0; i--) messages[i].stopTransition();
		transCount = 0; // 一
	}

	function callExchangeInfo()
	{
		// すべての背景レイヤをのぞく表レイヤにして
		// exchangeInfo を呼ぶ
		var layers = fore.layers, messages = fore.messages;
		for(var i = layers.count-1; i >= 0; i--) layers[i].exchangeInfo();
		for(var i = messages.count-1; i >= 0; i--) messages[i].exchangeInfo();
	}

	function callAssignTransSrc()
	{
		// すべての背景レイヤをのぞく表レイヤにして
		// assignTransSrc を呼ぶ
		var layers = fore.layers, messages = fore.messages;
		for(var i = layers.count-1; i >= 0; i--) layers[i].assignTransSrc();
		for(var i = messages.count-1; i >= 0; i--) messages[i].assignTransSrc();
		forEachEventHook('onCopyLayer',
				function(handler, f) { handler(f.toback); } incontextof this,
				%[toback:false]);
	}

	function exchangeForeBack()
	{
		// レイヤのYと表を取り替える
		var tmp = fore;
		fore = back;
		back = tmp;
		current = (currentPage?back:fore).messages[currentNum]; // current はO定し直し
		forEachEventHook('onExchangeForeBack',
				function(handler, f) { handler(); } incontextof this);

		// 制表示涓
		fore.base.visible = true;
		back.base.visible = false;
	}

	function swapBaseLayer()
	{
		// 背景レイヤのみを取り替える
		var tmp = fore.base;
		fore.base = back.base;
		back.base = tmp;
		current = (currentPage?back:fore).messages[currentNum]; // current はO定し直し
	}

	function swapCharacterLayer(id)
	{
		// 前景レイヤの表とYを取り替える
		var fl = fore.layers, bl = back.layers;
		var tmp = fl[id];
		fl[id] = bl[id];
		bl[id] = tmp;
	}

	function swapMessageLayer(id)
	{
		// メッセ`ジレイヤの表とYを取り替える
		var fl = fore.messages, bl = back.messages;
		var tmp = fl[id];
		fl[id] = bl[id];
		bl[id] = tmp;
		current = (currentPage?back:fore).messages[currentNum]; // current はO定し直し
	}

	//--------------------------------------------------------- 自右娱vB --

	function onLayerMoveStop()
	{
		// レイヤの自右婴K了した
		conductor.trigger('move');
	}

	function waitMove(elm)
	{
		// 自右婴虼つ
		if(moveCount == 0) return 0; // 自右婴虼てない
		if((elm.canskip === void || +elm.canskip) && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ幼髦
				stopAllMoves();
				return 0; // 自右婴蛲Ｖ工丹护皮工挨朔丹
			}
			conductor.wait(%[
				click : function
				{
					updateBeforeCh = 1;
					stopAllMoves(); // すべてのトランジションは停止
				} incontextof this,
				move : function
				{
					updateBeforeCh = 1;
				} incontextof this
				]);
		}
		else
		{
			conductor.wait(%[
				move : function
				{
					updateBeforeCh = 1;
				} incontextof this
				]);
		}
		return -2;
	}

	function stopAllMoves()
	{
		// すべての自右婴蛲Ｖ工丹护
		var layers, messages;
		fore.base.stopMove();
		back.base.stopMove();
		layers = fore.layers, messages = fore.messages;
		for(var i = layers.count-1; i >= 0; i--) layers[i].stopMove();
		for(var i = messages.count-1; i >= 0; i--) messages[i].stopMove();
		layers = back.layers, messages = back.messages;
		for(var i = layers.count-1; i >= 0; i--) layers[i].stopMove();
		for(var i = messages.count-1; i >= 0; i--) messages[i].stopMove();
		moveCount = 0; // 一
	}

	//------------------------------------------------ ディレイ/スキップvB --

	function setDelay(elm)
	{
		// delay タグのI理
		var speed = elm.speed;
		if(speed == 'nowait')
		{
			chSpeed = 0;
			chUserMode = false;
		}
		else if(speed == 'user')
		{
			chUserMode = true;
			setUserSpeed();
		}
		else
		{
			chSpeed = +speed;
			chUserMode = false;
		}
		if(!skipMode) actualChSpeed = chSpeed;
	}

	function getCurrentRead()
	{
		// F在のシナリオ部分が既iかどうかを判定する
		return autoRecordPageShowing && currentRecordName != "" &&
				+sflags[currentRecordName] || !autoRecordPageShowing;
	}

	function setUserSpeed()
	{
		// ユ`ザのxkした文字表示スピ`ドをO定
		// このv数をiんだr点ですでに userChSpeed には
		// あたらしいがO定されているとみなす。
		// あるいは、ラベルごとに、その区域が既iか未iかで
		// 表示スピ`ドを浃à肽康膜呛簸肖欷
		if(chUserMode)
		{
			if(getCurrentRead())
				chSpeed = userCh2ndSpeed==-1?userChSpeed:userCh2ndSpeed; // 既i
			else
				chSpeed = userChSpeed; // 未i
		}
		if(!skipMode) actualChSpeed = chSpeed;
	}

	function skipToClick()
	{
		// クリック待ち号までスキップ
		skipMode = 1;
		actualChSpeed = 0;
	}

	function skipToPage()
	{
		// 改ペ`ジ待ち号までスキップ
		skipMode = 2;
		actualChSpeed = 0;
	}

	function skipToStop()
	{
		// 次の停止までスキップ
		onPrimaryClick(); // クリックの幼鳏颔ē撺濂飑`トする
		skipMode = 3;
		actualChSpeed = 0;
	}

	function skipToStop2()
	{
		// 次の停止までスキップ(早送りモ`ド)
		onPrimaryClick();
		skipMode = 4;
		actualChSpeed = 0;
	}

	function cancelSkip()
	{
		// スキップ幼鳏颔ャンセル
		if(skipMode == 4) skipKeyRepressed = false;
		skipMode = 0;
		actualChSpeed = chSpeed;
	}

	function enterNoWait()
	{
		// nowait タグのI理
		beforeNoWaitActualChSpeed = actualChSpeed;
		beforeNoWaitChUserMode = chUserMode;
		actualChSpeed = 0;
	}

	function leaveNoWait()
	{
		// endnowait タグのI理
		actualChSpeed = beforeNoWaitActualChSpeed;
		chUserMode = beforeNoWaitChUserMode;
	}

	function setAutoWait(elm)
	{
		// 自鹰ΕДぅ趣蛟O定する
		autoWCEnabled = +elm.enabled if elm.enabled !== void;
		autoWCChars = elm.ch if elm.ch !== void;
		autoWCWaits = [].split(",", elm.time) if elm.time !== void;
	}

	function cancelAutoMode()
	{
		// 自诱iみすすみモ`ドのキャンセル
		if(autoMode)
		{
			autoMode = false;
			if(typeof this.autoModeMenuItem !== "undefined")
				autoModeMenuItem.checked = false;
			var t = conductor.lastTagName;
			if(t == 'p'){
				showPageBreak();
			}
			else if(t == 'l'){
				showLineBreak(%[canskip: false]);
			}
		}
	}

	function enterAutoMode()
	{
		// 自诱iみすすみモ`ドに入る
		if(typeof this.autoModeMenuItem !== "undefined")
			autoModeMenuItem.checked = true;
		if(inStable)
			onPrimaryClick();
		autoMode = true;
	}

	//--------------------------------------------------------- ウェイトvB --

	function resetWait()
	{
		// rg原点のリセット
		timeOrigin = System.getTickCount();
	}

	function waitTime(waittime, canskip)
	{
		// waittime 分待つ
		if(waittime == 0) return 0;
		if(canskip)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ中の龊
				return 0; // スキップ中の龊悉悉胜摔猡护氦朔丹
			}
			conductor.waitWithTimeOut(%[
				click : function
				{
					// やることなし
				} incontextof this,

				timeout : function
				{
					// やることなし
				} incontextof this
				], waittime);
		}
		else
		{
			// スキップできない龊
			conductor.waitWithTimeOut(%[
				timeout : function
				{
					// やることなし
				} incontextof this
				], waittime);
		}
		return -2; // break
		
	}

	function doWait(elm)
	{
		// wait タグのI理
		var waittime;
		if(elm.mode == 'until')
		{
			// until モ`ド
			waittime = timeOrigin + +elm.time - System.getTickCount();
			if(waittime < 0) { lastWaitTime = 0; return 0; } // すでにrgがU^している
			lastWaitTime = waittime;
			if(waittime < 6) return 0; // あまりに待ちrgが短いので待たない
		}
		else
		{
			waittime = +elm.time;
		}
		return waitTime(waittime, (elm.canskip === void || +elm.canskip) && clickSkipEnabled);
	}

	function doWaitCh(elm)
	{
		// +elm.time のカウント分、待つ
		var t = elm.time;
		return waitTime(actualChSpeed * (t === void ? 1 : +t),
			(elm.canskip === void || +elm.canskip) && clickSkipEnabled);
	}

	//------------------------------------------------------------ quakevB --

	function doQuake(elm)
	{
		// elm に兢盲 quake を_始
		if(elm.time !== void)
		{
			if(defaultQuakeTimeInChUnit)
			{
				if(elm.timemode == 'ms')
					quakeEndTick = System.getTickCount() + +elm.time;
				else
					quakeEndTick = System.getTickCount() + +elm.time * chSpeed;
			}
			else
			{
				if(elm.timemode == 'delay')
					quakeEndTick = System.getTickCount() + +elm.time * chSpeed;
				else
					quakeEndTick = System.getTickCount() + +elm.time;
			}
		}
		else
		{
			quakeEndTick = -1;
		}

		if(elm.hmax !== void) quakeHorzMax = +elm.hmax; else quakeHorzMax = 10;
		if(elm.vmax !== void) quakeVertMax = +elm.vmax; else quakeVertMax = 10;

		quakeTimer.enabled = true;
		quaking = true;
	}

	function restoreQuake()
	{
		// restore から呼ばれ、荬虮４妞筏郡趣にeれていた龊悉eらす
		if(quaking && quakeEndTick == -1)
			quakeTimer.enabled =true;
		// MEMO: time 属性付きの quake は restore() rに途嗓丹欷胜い
		//  セ`ブラベルと quake の位置によっては quaking のが狂う龊悉ある。
		//  quaking 自体あまり必要にはえないが互Q性S持のためここでゅ辘蚝悉铯护皮く。
		else
		if(!quakeTimer.enabled)	// `って restoreQuake() が呼び出された龊悉 quaking の保o
			quaking = false;
	}

    /**
     * レイヤ位置の{整
     */
	function setBaseLayerPos(x, y) {
		(global.Layer.setPos incontextof fore.base)(x,y);
		(global.Layer.setPos incontextof back.base)(x,y);
		forEachEventHook('setBaseLayerPos',
						 function(handler, info) { handler(info.x, info.y); } incontextof this, %[x:x, y:y]);
	}
	
	function stopQuake()
	{
		// eれを停止
		setBaseLayerPos(0, 0);
		quakeTimer.enabled = false;
		quaking = false;
		conductor.trigger('quake');
	}

	function onQuakeTimerInterval()
	{
		// quakeTimer により呼ばれる
		if(quakeEndTick != -1 && System.getTickCount() > quakeEndTick) { stopQuake(); return; }
		if(historyShowing)
		{
			// メッセ`ジ履sレイヤ表示中はさすがにeれていられない
			setBaseLayerPos(0, 0);
			return;
		}
		var x, y;
		if(quakeHorzMax == quakeVertMax)
		{
			// だいたい同じ
			x = int(Math.random() * quakeHorzMax - quakeHorzMax);
			y = int(Math.random() * quakeVertMax - quakeVertMax);
		}
		else if(quakeHorzMax < quakeVertMax)
		{
			// keれ
			x = int(Math.random() * quakeHorzMax - quakeHorzMax);
			y = int((quakePhase ? Math.random() : -Math.random()) * quakeVertMax);
		}
		else
		{
			// 横eれ
			x = int((quakePhase ? Math.random() : -Math.random()) * quakeHorzMax);
			y = int(Math.random() * quakeVertMax - quakeVertMax);
		}
		quakePhase = !quakePhase;
		setBaseLayerPos(x, y);
	}

	function waitQuake(elm)
	{
		// eれがK了するまでまつ
		if(!quaking || quakeEndTick == -1) return 0; // eれていなければ待たない
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ中の龊
				stopQuake();
				return 0; // スキップ中の龊悉eれを停止させて返る
			}
			conductor.wait(%[
				click : function
				{
					stopQuake(); // eれは停止する
				} incontextof this,

				quake : function
				{
					// やることなし
				} incontextof this
				]);
		}
		else
		{
			// スキップできない龊
			conductor.wait(%[
				quake : function
				{
					// やることなし
				} incontextof this
				]);
		}
		return -2;
	}

	//------------------------------------------------------------- クリック --

	function onPrimaryClick()
	{
		// プライマリレイヤで「クリックの幼鳌工なにもフィルタリングされなかった
		// とき、プライマリレイヤから呼ばれる。
		clickCount ++;
		if(!callHook(leftClickHook))
		{
			if(messageLayerHiding)
			{
				showMessageLayerByUser(); // メッセ`ジレイヤを表示する
			}
			else
			{
				var st = conductor.status;
				var runst = conductor.mRun;
				var stopst = conductor.mStop;

				if(st != stopst && autoMode)
				{
					// 自诱iみすすみの龊
					cancelAutoMode();
				}
				else if(st != stopst && canCancelSkipByClick && skipMode && skipMode != 4)
				{
					// クリックによるスキップの解除が可能
					cancelSkip();
				}
				else
				{
					// このr点でフィルタリングされないメッセ`ジは待ち状Bのクリアなので
					// conductor に 'click' を送り解除を护à搿

					if(!conductor.trigger('click')) // 待ち状Bでない龊悉gにoされる
					{
						// ハンドラがつからないなど、I理されなかった龊
						if(st == runst && clickSkipEnabled && skipMode == 0)
						{
							// クリックによるスキップが可能
							skipToClick();
						}
					}
				}
			}
		}
	}

	function onPrimaryClickByKey()
	{
		// キ`が押されたときプライマリレイヤをクリックしたのと
		// 同じ幼鳏颏工毪、さらに一r的にマウスカ`ソルをLす
		onPrimaryClick();
		hideMouseCursor();
	}

	function waitClick(elm)
	{
		// クリックを待つ
		conductor.wait(%[
			click : function
			{
			} incontextof this]);
		return -2;
	}

	function onMouseDown(x, y)
	{
		lastMouseDownX = x;
		lastMouseDownY = y;
		super.onMouseDown(...);
	}

	//------------------------------------------------------- キ`ボ`ド操作 --

	function processKeys(key, shift)
	{
		if(checkProceedingKey(key, shift)) return;

		if(key == #'F')
		{
			// 次のxk肢/未iまでMむ
			skipToNextStopByKey();
			return;
		}

		if(key == #'B')
		{
			// 前にる
			goBackByKey();
			return;
		}

		if(key == #'A')
		{
			// 自拥膜苏iみMめる
			switchAutoModeByKey();
			return;
		}

		if(freeSaveDataMode)
		{
			if(key == #'S')
			{
				// 荬颏悉丹
				if(typeof this.storeMenu != "undefined" && storeMenu.enabled)
					storeMenu.click();
				return;
			}

			if(key == #'L')
			{
				// 荬颏郡嗓
				if(typeof this.restoreMenu != "undefined" && restoreMenu.enabled)
					restoreMenu.click();
				return;
			}
		}

		if(key == #'R' || (key == VK_UP && (shift & ssShift)))
		{
			// メッセ`ジ履sを表示
			showHistoryByKey();
			return;
		}

		if(key == VK_ESCAPE)
		{
			// メッセ`ジを消す
			if(typeof this.rightClickMenuItem != "undefined" &&
				rightClickMenuItem.enabled)
			{
				rightClickMenuItem.click(); // クリックをエミュレ`ト
				return;
			}
		}
	}

	function preProcessKeys(key, shift)
	{
		return callHook(keyDownHook, key, shift);
	}

	function internalOnKeyDown(key, shift)
	{
		if(!preProcessKeys(key, shift)) processKeys(key, shift);
	}

	function checkProceedingKey(key, shift)
	{
		// key がiみすすみのキ` ( スペ`スキ`かReturnキ` ) の龊悉
		// キ`をI理し、true を返す。そうでなければ false を返す
		if(key == VK_RETURN || key == supportReadingKey)
		{
			// キ`がメッセ`ジキュ`に溜まってる龊悉あるので
			// gHにそのキ`が押されているのかどうかを
			// getKeyState を用いて{べる
			var sg = getKeyState;
			if(sg(VK_RETURN) || sg(supportReadingKey))
			{
				// キ`が押されてた
				if((shift & ssRepeat) && clickSkipEnabled)
				{
					// キ`リピ`ト
					if(skipMode != 4 && skipKeyRepressed)
						skipToStop2(); // まだskipMode 4に入っていない龊悉显缢亭辚猢`ドに入る
					// skipKeyRepressed をチェックするのは
					// BAしてキ`リピ`トがk生しているときに
					// cancelSkip 後にスキップに突入するのを防ぐため
				}
				else
				{
					skipKeyRepressed = true;
					onPrimaryClickByKey();
				}
				return true;
			}
		}

		return false;
	}

	function skipCancelKeyPressing()
	{
		// スキップを解除する要因となるキ`あるいはマウスボタンが押されているか
		var sg = getKeyState;
		return sg(VK_RETURN) || sg(supportReadingKey) || sg(VK_LBUTTON);
	}

	function skipKeyPressing()
	{
		// VK_RETURN あるいは supportReadingKey が押されているかどうか
		var sg = getKeyState;
		return sg(VK_RETURN) || sg(supportReadingKey);
	}

	function goBackByKey()
	{
		if(typeof this.goBackMenuItem != "undefined" &&
			goBackMenuItem.enabled)
			goBackMenuItem.click(); // クリックをエミュレ`ト
	}

	function skipToNextStopByKey()
	{
		if(typeof this.skipToNextStopMenuItem != "undefined" &&
			skipToNextStopMenuItem.enabled)
			skipToNextStopMenuItem.click(); // クリックをエミュレ`ト
	}

	function showHistoryByKey()
	{
		if(typeof this.showHistoryMenuItem != "undefined" &&
			showHistoryMenuItem.enabled)
			showHistoryMenuItem.click(); // クリックをエミュレ`ト
	}

	function switchAutoModeByKey()
	{
		if(typeof this.autoModeMenuItem != "undefined" &&
			autoModeMenuItem.enabled)
			autoModeMenuItem.click(); // クリックをエミュレ`ト
	}

	function onKeyDown(key, shift)
	{
		if(focusedLayer === null)
			internalOnKeyDown(key, shift);
		super.onKeyDown(...);
	}

	function onMouseWheel(shift, delta, x, y)
	{
		// ホイ`ルが回した
		super.onMouseWheel(...);
        // メッセ`ジのホイ`ルI理
        if (inSleep && current.hasWheel()) {
            current.processWheel(shift, delta, x, y);
            return;
        }
		if(!historyLayer.visible)
		{
			if(delta > 0)
				showHistoryByKey(); // メッセ`ジ履sを表示
			else if(System.getTickCount() - lastHistoryHiddenTick > 150) 
					onPrimaryClick(); // クリックをエミュレ`ト
			// ↑ tick を比^しているのは、メッセ`ジ履sをLす操作とホイ`ルを
			// 手前に回す操作がBAした龊悉偈证苏iみMむのをある程度防ぐ仕欷
		}
		else
		{
			// メッセ`ジ履sにイベントを垂れ流す
			historyLayer.windowMouseWheel(shift, delta, x, y);
		}
	}

	function onMouseDown(x, y, button)
	{
		// フルスクリ`ンrの画面外クリックを判定
		if (fullScreened)
		{
			// x,yはg座摔韦郡幞抓楗ぅ蕙辚欹ぅ浃桥卸
			var pl = primaryLayer;
			var px = pl.cursorX;
			var py = pl.cursorY;

			if (px < 0 || py < 0 || px >= pl.width || py >= pl.height)
			{
				if (button == mbLeft)
				{
					onPrimaryClick();
				}
				else if (button == mbRight)
				{
					onPrimaryRightClick();
				}
			}
		}
		super.onMouseDown(...);
	}

	//------------------------------------------------- クリック待ち号I理 --

	function hideClickGlyphs()
	{
		// クリック待ち号を非表示に
		lineBreak.visible = false;
		pageBreak.visible = false;
		if(conductor == mainConductor)
		{
			// クリック待ち号の状Bをh
			lastClickGlyphVisible = false;
		}
	}

	function storeClickGlyphState(which)
	{
		// クリック待ち号の情螭蛞r的に待避
		// このデ`タは右クリックサブル`チンやextraConductorサブル`チンからるときに参照する
		if(conductor == mainConductor)
		{
			lastClickGlyphVisible = true;
			lastClickGlyphMessagePage = currentPage;
			lastClickGlyphMessageNum = currentNum;
			lastClickGlyphWhich = which;
		}
	}

	function restoreClickGlyphState()
	{
		// lastClickGlyph *** に一r的に待避したクリック待ち号の情
		// に基づいてクリック待ち号をO定する
		if(lastClickGlyphVisible)
		{
			var layer = getMessageLayerObjectFromPageAndNumber
				(lastClickGlyphMessagePage, lastClickGlyphMessageNum);
			if(layer !== void)
			{
				switch(lastClickGlyphWhich)
				{
				case 'line':
					layer.showLineBreakGlyph(lineBreak);
					break;
				case 'page':
					layer.showPageBreakGlyph(pageBreak);
					break;
				}
			}
		}
	}

	function canIgnoreL()
	{
		// L タグをoできるかどうか
		return chNonStopToPageBreak || (getCurrentRead() && ch2ndNonStopToPageBreak);
	}

	function showLineBreak(elm)
	{
		// F在のメッセ`ジレイヤに行待ち号を表示する
		stablePosibility = true;
		if(canIgnoreL())
		{
			// l タグのo
			if(elm.canskip === void || !+elm.canskip)
				return (skipMode==3 || skipMode==4) ? 0 : -4;
		}
		if(autoMode)
		{
			// 自诱iみすすみの龊
			return autoModeLineWait;
		}
		if(skipMode == 1) cancelSkip();
		if(skipMode == 4 && !skipKeyPressing()) cancelSkip();
		if(skipMode == 4) return -4;
		if(skipMode) return skipCancelKeyPressing()?-4:0;
			// スキップ中(スキップをキャンセルするようなキ`があればスキップ解除
			// のためのイベントI理のC会を与える)

		current.showLineBreakGlyph(lineBreak);
		storeClickGlyphState("line");

		if(!current.nodeVisible)
		{
			dm("警告 : 非表示になっている" +
				(currentPage ? "Y" : "表") + "メッセ`ジレイヤ" + currentNum +
				"で行クリック待ちになりました");
		}

		// conductor を 'click' まで待ち状Bに
		conductor.wait(%[
			click : function
			{
				clickWaiting = false;
				fore.base.cursor = cursorDefault;
				notifyRun();
			} incontextof this
			]);
		clickWaiting = true;
		fore.base.cursor = cursorWaitingClick;
		notifyStable();
		return -2;
	}

	function showPageBreak(elm)
	{
		// F在のメッセ`ジレイヤにペ`ジ待ち号を表示する
		stablePosibility = true;
		if(skipMode == 1 || skipMode == 2) cancelSkip();
		if(skipMode == 4 && !skipKeyPressing()) cancelSkip();
		if(skipMode) return -4; // いったんイベントをI理
		if(autoMode)
		{
			// 自诱iみすすみの龊
			return autoModePageWait;
		}

		current.showPageBreakGlyph(pageBreak);
		storeClickGlyphState("page");

		if(!current.nodeVisible)
		{
			dm("警告 : 非表示になっている" +
				(currentPage ? "Y" : "表") + "メッセ`ジレイヤ" + currentNum +
				"でペ`ジクリック待ちになりました");
		}

		// conductor を 'click' まで待ち状Bに
		conductor.wait(%[
			click : function
			{
				clickWaiting = false;
				fore.base.cursor = cursorDefault;
				notifyRun();
			} incontextof this
			]);
		clickWaiting = true;
		fore.base.cursor = cursorWaitingClick;
		notifyStable();
		return -2;
	}

	function showPageBreakAndClear()
	{
		// メッセ`ジレイヤが最K行まで_して自痈磨讴`ジがされるときに
		// 呼ばれる。F在のメッセ`ジレイヤにペ`ジ待ち号を表示し、
		// g行再_rには MessageLayer.clear2 を呼ぶ
		stablePosibility = true;
		if(skipMode == 1 || skipMode == 2) cancelSkip();
		if(skipMode == 4 && !skipKeyPressing()) cancelSkip();
		var lasttagname = conductor.lastTagName;
		if((!autoMode && ((!canIgnoreL() && lasttagname == 'l') || lasttagname == 'p')) || skipMode)
		{// いったんイベントをI理(タグは後回し)
			current.comp.clear2() if currentWithBack;
			current.clear2();
			return -5;
		}

		if(!current.nodeVisible)
		{
			dm("警告 : 非表示になっている" +
				(currentPage ? "Y" : "表") + "メッセ`ジレイヤ" + currentNum +
				"で自痈磨讴`ジクリック待ちになりました");
		}

		if(autoMode)
		{
			conductor.waitWithTimeOut(%[ // タイムアウト付きウェイト
				click : function
				{
					current.comp.clear2() if currentWithBack;
					current.clear2(); // clear2 を呼ぶ
					cancelAutoMode();
				} incontextof this,
				timeout : function
				{
					current.comp.clear2() if currentWithBack;
					current.clear2(); // clear2 を呼ぶ
				} incontextof this
				], autoModePageWait <= 0 ? 1 : autoModePageWait);
			return -3;
		}
		else
		{
			current.comp.showPageBreakGlyph(pageBreak) if currentWithBack;
			current.showPageBreakGlyph(pageBreak);
			storeClickGlyphState("page");

			// conductor を 'click' まで待ち状Bに
			conductor.wait(%[
				click : function
				{
					clickWaiting = false;
					fore.base.cursor = cursorDefault;
					current.comp.clear2() if currentWithBack;
					current.clear2(); // clear2 を呼ぶ
					notifyRun();
				} incontextof this
				]);
			clickWaiting = true;
			fore.base.cursor = cursorWaitingClick;
			notifyStable();
			return -3;
		}
	}

	//------------------------------------------------------------- BGM I理 --

	function onBGMFadeCompleted()
	{
		// BGM のフェ`ドが完了した
		conductor.trigger('bgmfade');
	}

    // BGM停止I理
    var bgmStopExp;
    var bgmStopStorage;
    var bgmStopTarget;

    function handleBgmStop() {
        // BGM停止ハンドラ

        // パラメ`タを保持して破
        var exp     = bgmStopExp;
        var storage = bgmStopStorage;
        var target  = bgmStopTarget;
        clearBgmStop();
        
        // I理g行
        if (exp !== void) {
            Scripts.eval(exp);
        }
        if (storage !== void || target !== void) {
            process(storage, target);
        }
    }
	
    function setBgmStop(elm) {
        // BGM停止rI理の登h
        bgmStopExp     = elm.exp;
        bgmStopStorage = elm.storage;
        bgmStopTarget  = elm.target;
    }
    
    function clearBgmStop() {
        // BGM停止rI理の解除
        bgmStopExp     = void;
        bgmStopStorage = void;
        bgmStopTarget  = void;
    }
    
	function onBGMStop()
	{
		// BGM が停止した
		conductor.trigger('bgmstop');
        if (bgmStopExp !== void || bgmStopStorage !== void || bgmStopTarget !== void) {
            global.stopBgmTrigger = new AsyncTrigger(handleBgmStop, '');
            global.stopBgmTrigger.cached = true;
            global.stopBgmTrigger.trigger();
        }
	}
    // ------------------------------------------
    
    var bgmLabelInfos = %[];
    var bgmLabelInfo;

    function handleBgmLabel() {
        if (bgmLabelInfo !== void) {
            if (bgmLabelInfo.exp !== void) {
                Scripts.eval(bgmLabelInfo.exp);
            }
            if (bgmLabelInfo.storage !== void || bgmLabelInfo.target !== void) {
                process(bgmLabelInfo.storage, bgmLabelInfo.target);
            }
        }
    }

    function onBGMLabel(label) {
        // BGM のラベル通^I理
        conductor.trigger('bgmlabel_' + label);
        var obj = bgmLabelInfos[label];
        if (obj !== void) {
            bgmLabelInfo = obj;
            global.labelBgmTrigger = new AsyncTrigger(handleBgmLabel, '');
            global.labelBgmTrigger.cached = true;
            global.labelBgmTrigger.trigger();
        }
    }

    /**
     * BGM ラベルI理の登h
     */
    function setBgmLabel(elm) {
        if (elm.name !== void) {
            var obj = %[];
            obj.storage = elm.storage;
            obj.target  = elm.target;
            obj.exp     = elm.exp;
            bgmLabelInfos[elm.name] = obj;
        }
    }

    /**
     * BGM ラベルI理の解除
     */
    function clearBgmLabel() {
        bgmLabelInfos = %[];
        bgmLabelInfo = void;
    }

    // ----------------------------------------------------------------------
    
	function waitBGMFade(elm)
	{
		// BGM のフェ`ドK了を待つ
		if(!bgm.inFading) return 0; // フェ`ド中でなければ待たない
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ中の龊
				bgm.stopFade();
				return 0; // スキップ中の龊悉膝榨З`ドを停止させて返る
			}
			conductor.wait(%[
				click : function
				{
					bgm.stopFade(); // フェ`ディングは停止する
				} incontextof this,

				bgmfade : function
				{
					// やることなし
				} incontextof this
				]);
		}
		else
		{
			// スキップできない龊
			conductor.wait(%[
				bgmfade : function
				{
					// やることなし
				} incontextof this
				]);
		}
		return -2;
	}

	function waitBGMStop(elm)
	{
		// BGM の再生K了を待つ
		if(!bgm.canWaitStop) return 0; // BGM 再生K了を待てなければそのままる
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ中の龊
				bgm.stop();
				return 0; // スキップ中の龊悉显偕を停止させて返る
			}
			conductor.wait(%[
				click : function
				{
					bgm.stop(); // 再生をK了する
				} incontextof this,

				bgmstop : function
				{
					// やることなし
				} incontextof this
				]);
		}
		else
		{
			// スキップできない龊
			conductor.wait(%[
				bgmstop : function
				{
					// やることなし
				} incontextof this
				]);
		}
		return -2;
	}

	//----------------------------------------------------------- 抗音I理 --

	function onSESoundBufferFadeCompleted(id)
	{
		// 抗音のフェ`ドがK了した
		conductor.trigger('sefade' + id);
	}

	function onSESoundBufferStop(id)
	{
		// 抗音の再生がK了した
		conductor.trigger('sestop' + id);
	}

	function waitSEFade(elm)
	{
		var id = +elm.buf;
		var buf = se[id];
		if(!buf.inFading) return 0; // フェ`ド中でなければそのままる
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ中の龊
				buf.stopFade();
				return 0; // スキップ中の龊悉膝榨З`ドを停止させて返る
			}
			conductor.wait(%[
				click : function (id)
				{
					se[id].stopFade(); // フェ`ドをK了する
				} incontextof this,

				click_arg : id, // ハンドラへの引数

				'sefade'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'sefade'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		else
		{
			// スキップできない龊
			conductor.wait(%[
				'sefade'+id =>
					function (id)
					{
						// やることなし
					} incontextof this,

				'sefade'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		return -2;
	}

	function waitSEStop(elm)
	{
		var id = +elm.buf;
		var buf = se[id];
		if(!buf.canWaitStop()) return 0; // K了を待てなければそのまま返る
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ中の龊
				buf.stop();
				return 0; // スキップ中の龊悉显偕を停止させて返る
			}
			conductor.wait(%[
				click : function (id)
				{
					se[id].stop(); // 再生をK了する
				} incontextof this,

				'click_arg' => id, // ハンドラへの引数

				'sestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'sestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		else
		{
			// スキップできない龊
			conductor.wait(%[
				'sestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'sestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		return -2;
	}

	//--------------------------------------------------------- ム`ビ`vB --

	function onMovieStop(id)
	{
		// ム`ビ`の再生がK了した
		conductor.trigger('moviestop'+id);
	}

	function waitMovieStop(elm)
	{
		var id = +elm.slot;

		// ム`ビ`の再生K了を待つ
		if(!movies[id].canWaitStop) return 0; // ム`ビ`再生K了を待てなければそのままる
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる龊
			if(skipMode)
			{
				// スキップ中の龊
				movies[id].stop();
				return 0; // スキップ中の龊悉显偕を停止させて返る
			}
			conductor.wait(%[
				click : function (id)
				{
					movies[id].stop(); // 再生をK了する
				} incontextof this,

				'click_arg' => id, // ハンドラへの引数

				'moviestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'moviestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		else
		{
			// スキップできない龊
			conductor.wait(%[
				'moviestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'moviestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		return -2;
	}

	function onMoviePeriod(id,type)
	{
		// ム`ビ`のピリオドイベントがk生した
		if( isLeavePeriodEvent != false )
		{
			holdPeriodEventQueue.add( 'movieperiod'+id+'_'+type );
		}
		else
		{
			conductor.trigger('movieperiod'+id+'_'+type);
		}
	}

	function waitMoviePeriod(elm)
	{
		isWaitPeriodEvent = true;
		waitedPeriodEventStorageName = conductor.curStorage;
	
		var id = +elm.slot;

		stablePosibility = true;

		if( holdPeriodEventQueue.count > 0 )
		{
			var		triggered = false;
			for( var i = 0; i < holdPeriodEventQueue.count; i++ )
			{
				if( elm.for !== void )
				{
					if( elm.for == 'loop' )
					{
						if( ('movieperiod'+id+'_'+perLoop) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else if( elm.for == 'period' )
					{
						if( ('movieperiod'+id+'_'+perPeriod) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else if( elm.for == 'prepare' )
					{
						if( ('movieperiod'+id+'_'+perPrepare) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else if( elm.for == 'segLoop' )
					{
						if( ('movieperiod'+id+'_'+perSegLoop) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else
					{
						triggered == true;
					}
				}
				else
				{
					triggered == true;
				}
			}
			holdPeriodEventQueue.clear();
			if( triggered == true )
			{
				isWaitPeriodEvent = false;
				return 0;
			}
		}

		// ム`ビ`のピリオドイベントを待つ
		if(!movies[id].canWaitStop) return 0; // ム`ビ`が再生中でなければそのままる
		if( elm.for !== void )
		{
			if( elm.for == 'loop' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else if( elm.for == 'period' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perPeriod => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else if( elm.for == 'prepare' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perPrepare => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else if( elm.for == 'segLoop' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perSegLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else
			{
				return 0; // 引数が
			}
		}
		else
		{
			conductor.wait(%[
				'movieperiod'+id+'_'+perLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_'+perPeriod => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_'+perPrepare => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_'+perSegLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		notifyStable();
		return -2;
	}

	//------------------------------------------------------- タグハンドラ群 --

	function getHandlers()
	{
		return %[ // 辞配列オブジェクト

		/*
			タグハンドラ群は、名前とそれに辘工腴v数のペアを列い工毪猡韦恰
			v数名 : function(elm)
			{
				// v数の中身
			} incontextof this,
			の式を用いる。ただし、v数名が予sZの龊悉稀「v数名 : 」ではなく
			「"v数名" => 」を用いる。
			incontextof this は、v数が正しく このクラスの
			オブジェクトのコンテキスト上で婴ようにするために必要。
		*/

	//--------------------------------------- タグハンドラ群(メッセ`ジ操作) --

	ch : function(elm)
	{
		// 文字表示
		var acs = actualChSpeed;
		if(updateBeforeCh)
		{
			if(acs) { updateBeforeCh--; return -5; } else { updateBeforeCh--; }
		}
		var text = elm.text;
		if(currentWithBack) current.comp.processCh(text);
		if(current.processCh(text))
		{
			return showPageBreakAndClear();
		}
		if(historyWriteEnabled) historyLayer.store(text);
		if(autoWCEnabled)
		{
			// 自鹰ΕДぅ
			var ind;
			if((ind = autoWCChars.indexOf(text)) != -1)
			{
				return int(acs * autoWCWaits[ind]);
			}
		}
		return acs;
	} incontextof this,

	graph : function(elm)
	{
		// グラフィックを文字として表示
		var acs = actualChSpeed;
		if(updateBeforeCh)
		{
			if(acs) { updateBeforeCh--; return -5; } else { updateBeforeCh--; }
		}
		if(currentWithBack) current.comp.processGraph(elm);
		if(current.processGraph(elm))
		{
			return showPageBreakAndClear();
		}
		if(historyWriteEnabled && elm.alt !== void) historyLayer.store(elm.alt);
		return acs;
	} incontextof this,

	hch : function(elm)
	{
		// k中横
		var acs = actualChSpeed;
		if(updateBeforeCh)
		{
			if(acs) { updateBeforeCh--; return -5; } else { updateBeforeCh--; }
		}
		var text = elm.text;
		var expand = elm.expand !== void && +elm.expand;
		if(currentWithBack) current.comp.putHorizonCh(text, expand);
		if(current.putHorizonCh(text, expand))
		{
			return showPageBreakAndClear();
		}
		if(historyWriteEnabled) historyLayer.store(text);
		return acs;
	} incontextof this,

	r : function(elm)
	{
		// 改行
		if(historyWriteEnabled) historyLayer.reline();
		if(currentWithBack) current.comp.processReturn();
		if(current.processReturn())
		{
			var ret = showPageBreakAndClear();
			// 改行はpendingしない
			if(ret == -5)
				ret = -4;
			else if(ret == -3)
				ret = -2;
			return ret;
		}
		return actualChSpeed;
	} incontextof this,

	ruby : function(elm)
	{
		// 次の文字にするルビO定
		if(currentWithBack) current.comp.setRuby(elm.text);
		current.setRuby(elm.text);
		return 0;
	} incontextof this,

	font : function(elm)
	{
		// フォントO定
		if(currentWithBack) current.comp.setFont(elm);
		current.setFont(elm);
		return 0;
	} incontextof this,

	deffont : function(elm)
	{
		// デフォルトのフォントO定
		if(currentWithBack) current.comp.setDefaultFont(elm);
		current.setDefaultFont(elm);
		return 0;
	} incontextof this,

	resetfont : function(elm)
	{
		// フォントのリセット
		if(currentWithBack) current.comp.resetFont();
		current.resetFont();
		return 0;
	} incontextof this,

	style : function(elm)
	{
		// スタイルO定
		if(currentWithBack) current.comp.setStyle(elm);
		current.setStyle(elm);
		return 0;
	} incontextof this,

	defstyle : function(elm)
	{
		// デフォルトのスタイルO定
		if(currentWithBack) current.comp.setDefaultStyle(elm);
		current.setDefaultStyle(elm);
		return 0;
	} incontextof this,

	resetstyle : function(elm)
	{
		// スタイルのリセット
		if(currentWithBack) current.comp.resetStyle();
		current.resetStyle();
		return 0;
	} incontextof this,

	link : function(elm)
	{
		// ハイパ`リンクの_始
		if(currentWithBack) current.comp.beginHyperLink(elm);
		current.beginHyperLink(elm);
		return 0;
	} incontextof this,

	endlink : function(elm)
	{
		// ハイパ`リンクのK了
		if(currentWithBack) current.comp.endHyperLink(elm);
		current.endHyperLink(elm);
		return 0;
	} incontextof this,

	button : function(elm)
	{
		// グラフィカルボタン
		if(currentWithBack) current.comp.addButton(elm);
		current.addButton(elm);
		return 0;
	} incontextof this,

	edit : function(elm)
	{
		// g一行集
		if(currentWithBack) current.comp.addEdit(elm);
		current.addEdit(elm);
		return 0;
	} incontextof this,

	checkbox : function(elm)
	{
		// g一行集
		if(currentWithBack) current.comp.addCheckBox(elm);
		current.addCheckBox(elm);
		return 0;
	} incontextof this,

	commit : function(elm)
	{
		// フォ`ム要素のコミット
		current.commit();
		return 0;
	} incontextof this,

    timeout : function(elm)
    {
        // タイムアウトI理の登h(カレントのみ)
        current.addTimeout(elm);
        return 0;
    } incontextof this,

    ctimeout : function(elm)
    {
        // タイムアウトI理の解除（カレントのみ）
        current.clearTimeout();
        return 0;
    } incontextof this,

    wheel : function(elm)
    {
        // ホイ`ルI理の登h(カレントのみ)
        current.addWheel(elm);
        return 0;
    } incontextof this,

    cwheel : function(elm)
    {
        // ホイ`ルI理の解除（カレントのみ）
        current.clearWheel();
        return 0;
    } incontextof this,
                  
    click : function(elm)
    {
        // クリックI理の登h(カレントのみ)
        current.addClick(elm);
        return 0;
    } incontextof this,

    cclick : function(elm)
    {
        // クリックI理の登h(カレントのみ)
        current.clearClick(elm);
        return 0;
    } incontextof this,

	l : function(elm)
	{
		// 行クリック待ち
		return showLineBreak(elm);
	} incontextof this,

	p : function(elm)
	{
		// ペ`ジクリック待ち
		if(historyWriteEnabled) historyLayer.reline();
		return showPageBreak(elm);
	} incontextof this,

	current : function(elm)
	{
		// 操作象のメッセ`ジレイヤの指定
		setCurrentMessageLayer(elm);
		return 0;
	} incontextof this,

	position : function(elm)
	{
		// メッセ`ジレイヤの位置、属性をO定
		getMessageLayerObjectFromElm(elm).setPosition(elm);
		return 0;
	} incontextof this,

	ct : function(elm)
	{
		// メッセ`ジレイヤのリセット(すべてのメッセ`ジレイヤのクリアと
		// current のリセット)
		if(historyWriteEnabled) historyLayer.repage();
		clearMessageLayers(true);
		return 0;
	} incontextof this,

	cm : function(elm)
	{
		// メッセ`ジレイヤのリセットを行うが、ct のように
		// current のリセットは行わないもの
		if(historyWriteEnabled) historyLayer.repage();
		clearMessageLayers(false);
		return 0;
	} incontextof this,

	er : function(elm)
	{
		// F在のメッセ`ジレイヤのクリア
		if(historyWriteEnabled) historyLayer.repage();
		if(currentWithBack) current.comp.clear();
		current.clear();
		return 0;
	} incontextof this,

	indent : function(elm)
	{
		// インデントのO定
		if(currentWithBack) current.comp.setIndent();
		current.setIndent();
		if(historyWriteEnabled) historyLayer.beginIndent();
		return 0;
	} incontextof this,

	endindent : function(elm)
	{
		// インデントの解除
		if(currentWithBack) current.comp.resetIndent();
		current.resetIndent();
		if(historyWriteEnabled) historyLayer.endIndent();
		return 0;
	} incontextof this,

	delay : function(elm)
	{
		// 文字表示速度の指定
		setDelay(elm);
		return 0;
	} incontextof this,

	nowait : function(elm)
	{
		// 一r的にノ`ウェイトでg行
		enterNoWait();
		return 0;
	} incontextof this,

	endnowait : function(elm)
	{
		// nowait の解除
		leaveNoWait();
		return 0;
	} incontextof this,

	locate : function(elm)
	{
		// 文字表示位置を指定
		if(currentWithBack) current.comp.locate(elm.x, elm.y);
		current.locate(elm.x, elm.y);
		return 0;
	} incontextof this,

	glyph : function(elm)
	{
		// クリック待ち号を指定
		current.setGlyph(elm);
		return 0;
	} incontextof this,

	locklink : function(elm)
	{
		// リンクのロック
		lockMessageLayerSelProcess();
		return 0;
	} incontextof this,

	unlocklink : function(elm)
	{
		// リンクのアンロック
		unlockMessageLayerSelProcess();
		return 0;
	} incontextof this,

	//----------------------------------------- タグハンドラ群(システム操作) --

	loadplugin : function(elm)
	{
		// プラグインのiみzみ
		Plugins.link(elm.module);
		dm("プラグインをiみzみました : " + elm.module);
		return 0;
	} incontextof this,

	title : function(elm)
	{
		// タイトルのO定
		setTitle(elm.name);
		return 0;
	} incontextof this,

	s : function(elm)
	{
		// g行停止
		stablePosibility = true;
		cancelSkip();
		if(!usingExtraConductor) incRecordLabel(true);
		inSleep = true;
		if(recordHistoryOfStore == 2) // 2 : xk肢 ( @s タグ ) ごと
			setToRecordHistory();
		notifyStable();

        // メッセ`ジレイヤタイムアウト呼び出し_始
        current.startTimeout();

		return -1;
	} incontextof this,

	clickskip : function(elm)
	{
		// クリックスキップのO定
		clickSkipEnabled = +elm.enabled;
		return 0;
	} incontextof this,

	nextskip : function(elm)
	{
		// 次のxk肢(/未i)までMむのO定
		nextSkipEnabled = +elm.enabled;
		return 0;
	} incontextof this,

	cancelskip : function(elm)
	{
		// スキップの解除
		cancelSkip();
		return 0;
	} incontextof this,

	cancelautomode : function(elm)
	{
		// 「自拥膜苏iみMむ」の解除
		cancelAutoMode();
		return 0;
	} incontextof this,

	resetwait : function(elm)
	{
		// rg原点のO定
		resetWait();
		return 0;
	} incontextof this,

	wait : function(elm)
	{
		// ウェイト
		return doWait(elm);
	} incontextof this,

	wc : function(elm)
	{
		// 指定文字分のウェイト
		return doWaitCh(elm);
	} incontextof this,

	waitclick : function(elm)
	{
		// クリックを待つ
		return waitClick(elm);
	} incontextof this,

	rclick : function(elm)
	{
		// 右クリックの幼髟O定
		setRightClickOptions(elm);
		return 0;
	} incontextof this,

	history : function(elm)
	{
		// メッセ`ジ履sレイヤのO定
		setHistoryOptions(elm);
		return 0;
	} incontextof this,

	showhistory : function(elm)
	{
		// メッセ`ジ履sレイヤの表示
		return showHistoryByScenario(elm);
	} incontextof this,

	hr : function(elm)
	{
		// メッセ`ジ履sレイヤに改行を出力
		if(historyWriteEnabled)
		{
			if(elm.repage !== void && +elm.repage)
				historyLayer.repage();
			else
				historyLayer.reline();
		}
		return 0;
	} incontextof this,

	hact : function(elm)
	{
		// メッセ`ジ履sにアクションをO定
		if(historyWriteEnabled)
			historyLayer.setNewAction(elm.exp);
		return 0;
	} incontextof this,

	endhact : function(elm)
	{
		// メッセ`ジ履sのアクションをクリア
		if(historyWriteEnabled)
			historyLayer.clearAction();
		return 0;
	} incontextof this,

	hidemessage : function(elm)
	{
		// メッセ`ジを一r的にLす
		return hideMessageLayerByScenario(elm);
	} incontextof this,

	quake : function(elm)
	{
		// eれ
		doQuake(elm);
		return 0;
	} incontextof this,

	stopquake : function(elm)
	{
		// eれの停止
		stopQuake();
		return 0;
	} incontextof this,

	wq : function(elm)
	{
		// eれの停止を待つ
		return waitQuake(elm);
	} incontextof this,

	autowc : function(elm)
	{
		// 自鹰ΕДぅ
		setAutoWait(elm);
		return 0;
	} incontextof this,

	cursor : function(elm)
	{
		// マウスカ`ソルの涓
		setCursor(elm);
		return 0;
	} incontextof this,

	close : function(elm)
	{
		// ウィンドウを]じる
		closeByScript(elm);
		return -2;
	} incontextof this,

	copybookmark : function(elm)
	{
		// 荬颔偿冤`
		copyBookMark(+elm.from, +elm.to);
		return 0;
	} incontextof this,

	erasebookmark : function(elm)
	{
		// 荬蛳鞒
		eraseBookMark(+elm.place);
		return 0;
	} incontextof this,

	disablestore : function(elm)
	{
		// 荬蛞r的に使用不可に
		tempDisableStore(elm);
		return 0;
	} incontextof this,

	store : function(elm)
	{
		// 荬问褂貌豢?使用可をO定する
		setStoreEnabled(+elm.enabled);
		return 0;
	} incontextof this,

	load : function(elm)
	{
		// 荬握iみzみ
		if(elm.ask !== void && +elm.ask)
			loadBookMarkWithAsk(+elm.place);
		else
			loadBookMark(+elm.place);
		return -4;
	} incontextof this,

	save : function(elm)
	{
		// 荬握iみzみ
		if(elm.ask !== void && +elm.ask)
			saveBookMarkWithAsk(+elm.place);
		else
			saveBookMark(+elm.place);
		return -4;
	} incontextof this,

	startanchor : function(elm)
	{
		// 「最初にる」の使用不可?使用可をO定する
		setStartAnchorEnabled(elm.enabled === void || +elm.enabled);
		return 0;
	} incontextof this,

	gotostart : function(elm)
	{
		// 「最初にる」
		if(elm.ask !== void && +elm.ask)
			goToStartWithAsk();
		else
			goToStart();
		return -4;
	} incontextof this,

	goback : function(elm)
	{
		// 通^hをる
		if(elm.ask !== void && +elm.ask)
			goBackHistory(true);
		else
			goBackHistory(false);
		return -4;
	} incontextof this,

	record : function(elm)
	{
		// 通^hをする
		setToRecordHistory();
		return 0;
	} incontextof this,

	tempsave : function(elm)
	{
		// 状Bのメモリへの保存
		tempSave(+elm.place);
		return 0;
	} incontextof this,

	tempload : function(elm)
	{
		// 状Bのメモリへの保存
		tempLoad(+elm.place, elm);
			//elm.se === void || +elm.se, elm.bgm === void || +elm.bgm,
			//elm.backlay !== void && +elm.backlay);
		return 0;
	} incontextof this,

	mappfont : function(elm)
	{
		// レンダリングgみフォントをF在のフォントにマッピング
		mapPrerenderedFont(elm.storage);
		return 0;
	} incontextof this,

	locksnapshot : function(elm)
	{
		// 画面のスナップショットをロックする
		lockSnapshot();
		return 0;
	} incontextof this,

	unlocksnapshot : function(elm)
	{
		// 画面のスナップショットのロックを解除する
		unlockSnapshot();
		return 0;
	} incontextof this,

	//------------------------------------------- タグハンドラ群(レイヤ操作) --

	image : function(elm)
	{
		// 画像iみzみ
		updateBeforeCh = 1;
		var start = System.getTickCount();
		getLayerFromElm(elm).loadImages(elm);
		dm(elm.storage + " のiみzみに " + (System.getTickCount() - start) + "ms かかりました");
		return 0;
	} incontextof this,

	img : function(elm)
	{
		// 画像iみzみ(imageとおなじ)
		updateBeforeCh = 1;
		var start = System.getTickCount();
		getLayerFromElm(elm).loadImages(elm);
		dm(elm.storage + " のiみzみに " + (System.getTickCount() - start) + "ms かかりました");
		return 0;
	} incontextof this,

	pimage : function(elm)
	{
		// 部分追加画像iみzみ
		getLayerFromElm(elm).loadPartialImage(elm);
		return 0;
	} incontextof this,

	ptext : function(elm)
	{
		// 背景/前景レイヤへの文字描画
		getLayerFromElm(elm).drawReconstructibleText(elm);
		return 0;
	} incontextof this,

	freeimage : function(elm)
	{
		// 画像のクリア
		updateBeforeCh = 1;
		getLayerFromElm(elm).freeImage(elm);
		return 0;
	} incontextof this,

	animstart : function(elm)
	{
		// アニメ`ションの_始
		updateBeforeCh = 1;
		getLayerFromElm(elm).startAnim(elm);
		return 0;
	} incontextof this,

	animstop : function(elm)
	{
		// アニメ`ションの停止
		updateBeforeCh = 1;
		getLayerFromElm(elm).stopAnim(+elm.seg);
		return 0;
	} incontextof this,

	wa : function(elm)
	{
		// アニメ`ションの停止待ち
		return waitAnimation(elm);
	} incontextof this,

	mapimage : function(elm)
	{
		// クリッカブルマップのI域画像をiみzむ
		getLayerFromElm(elm).loadProvinceImage(elm.storage);
		return 0;
	} incontextof this,

	mapaction : function(elm)
	{
		// クリッカブルマップのI域アクション定xをiみzむ
		getLayerFromElm(elm).loadProvinceActions(elm.storage);
		return 0;
	} incontextof this,

	mapdisable : function(elm)
	{
		// クリッカブルマップをo郡摔工
		getLayerFromElm(elm).clearProvinceActions();
		return 0;
	} incontextof this,

	backlay : function(elm)
	{
		// レイヤをY画面にコピ`
		updateBeforeCh = 1;
		backupLayer(elm, true);
		return 0;
	} incontextof this,

	forelay : function(elm)
	{
		// レイヤを表画面にコピ`
		updateBeforeCh = 1;
		backupLayer(elm, false);
		return 0;
	} incontextof this,

	copylay : function(elm)
	{
		// 同Nのレイヤ同士のコピ`
		updateBeforeCh = 1;
		copyLayer(elm);
		return 0;
	} incontextof this,

	layopt : function(elm)
	{
		// レイヤのオプションをO定
		updateBeforeCh = 1;
		getLayerFromElm(elm).setOptions(elm);
		return 0;
	} incontextof this,

	trans : function(elm)
	{
		// トランジションの_始
		getLayerPageFromElm(elm, false).beginTransition(elm);
		return 0;
	} incontextof this,

	wt : function(elm)
	{
		// トランジションを待つ
		return waitTransition(elm);
	} incontextof this,

	stoptrans : function(elm)
	{
		// トランジションを停止する
		stopAllTransitions();
		return 0;
	} incontextof this,

	move : function(elm)
	{
		// 自右婴伍_始
		getLayerFromElm(elm).beginMove(elm);
		return 0;
	} incontextof this,

	// layer, page, fps, ox, oy
	framemove : function(elm)
	{
		// フレ`ム指定自右婴伍_始
		getLayerFromElm(elm).beginFrameMove(elm);
		return 0;
	} incontextof this,

	wm : function(elm)
	{
		//  自右婴虼つ
		return waitMove(elm);
	} incontextof this,

	stopmove : function(elm)
	{
		// 自右婴蛲Ｖ工工
		stopAllMoves();
		return 0;
	} incontextof this,

	laycount : function(elm)
	{
		updateBeforeCh = 1;
		allocateCharacterLayers(+elm.layers) if elm.layers !== void;
		allocateMessageLayers(+elm.messages) if elm.messages !== void;
		return 0;
	} incontextof this,

	//------------------------------ タグハンドラ群(抗音?BGM?ビデオ操作) --

	playbgm : function(elm)
	{
		// BGM の演奏
		bgm.play(elm);
        clearBgmStop();
        clearBgmLabel();
		return 0;
	} incontextof this,

	stopbgm : function(elm)
	{
		// BGM の停止
		bgm.stop();
		return 0;
	} incontextof this,

	pausebgm : function(elm)
	{
		// BGM の一r停止
		bgm.pause();
		return 0;
	} incontextof this,

	resumebgm : function(elm)
	{
		// BGM の再_
		bgm.resume();
		return 0;
	} incontextof this,

	fadeinbgm : function(elm)
	{
		// BGM のフェ`ドイン
		bgm.fadeIn(elm);
		return 0;
	} incontextof this,

	fadeoutbgm : function(elm)
	{
		// BGM のフェ`ドアウト
		bgm.fadeOut(elm);
		return 0;
	} incontextof this,

	fadepausebgm : function(elm)
	{
		// BGM のフェ`ドポ`ズ
		bgm.fadePause(elm);
		return 0;
	} incontextof this,

	fadebgm : function(elm)
	{
		// BGM の指定音量までのフェ`ド
		bgm.fade(elm);
		return 0;
	} incontextof this,

	xchgbgm : function(elm)
	{
		// BGM の入れ替え/クロスフェ`ド
		bgm.exchange(elm);
        clearBgmStop();
        clearBgmLabel();
		return 0;
	} incontextof this,

	bgmopt : function(elm)
	{
		// BGM のオプションO定
		bgm.setOptions(elm);
		return 0;
	} incontextof this,
    setbgmstop : function(elm)
	{
		// BGM のK了rコ`ルバックの登h
        setBgmStop(elm);
        return 0;
	} incontextof this,

    clearbgmstop : function(elm)
	{
		// BGM のK了rコ`ルバックの削除
        clearBgmStop();
        return 0;
	} incontextof this,

    setbgmlabel : function(elm) {
        // BGM のラベルrコ`ルバックの登h
        setBgmLabel(elm);
        return 0;
    } incontextof this,

    clearbgmlabel : function(elm)
	{
        // BGM のラベルrコ`ルバックの削除
        clearBgmLabel();
        return 0;
	} incontextof this,

	wb : function(elm)
	{
		// BGM のフェ`ドK了待ち
		return waitBGMFade(elm);
	} incontextof this,

	wl : function(elm)
	{
		// BGM の再生K了待ち
		return waitBGMStop(elm);
	} incontextof this,

	playse : function(elm)
	{
		// 抗音の再生
		se[+elm.buf].play(elm);
		return 0;
	} incontextof this,

	stopse : function(elm)
	{
		// 抗音の停止
		se[+elm.buf].stop();
		return 0;
	} incontextof this,

	fadeinse : function(elm)
	{
		// 抗音のフェ`ドイン再生
		se[+elm.buf].fadeIn(elm);
		return 0;
	} incontextof this,

	fadeoutse : function(elm)
	{
		// 抗音のフェ`ドアウト
		se[+elm.buf].fadeOut(elm);
		return 0;
	} incontextof this,

	fadese : function(elm)
	{
		// 抗音のフェ`ド
		se[+elm.buf].fade(elm);
		return 0;
	} incontextof this,

	seopt : function(elm)
	{
		// 抗音のフェ`ド
		se[+elm.buf].setOptions(elm);
		return 0;
	} incontextof this,

	wf : function(elm)
	{
		// 抗音のフェ`ドK了待ち
		return waitSEFade(elm);
	} incontextof this,

	ws : function(elm)
	{
		// 抗音の再生K了待ち
		return waitSEStop(elm);
	} incontextof this,

	video : function(elm)
	{
		// ム`ビ`のオプションをO定する
		movies[+elm.slot].setOptions(elm);
		return 0;
	} incontextof this,

	playvideo : function(elm)
	{
		// ム`ビ`を再生する
		movies[+elm.slot].play(elm.storage);
		return 0;
	} incontextof this,

	stopvideo : function(elm)
	{
		// ム`ビ`を停止する
		movies[+elm.slot].stop();
		return 0;
	} incontextof this,

	openvideo : function(elm)
	{
		// ム`ビ`再生の浃颏工
		movies[+elm.slot].open(elm.storage);
		return 0;
	} incontextof this,

	wv : function(elm)
	{
		// ム`ビ`の再生K了を待つ
		return waitMovieStop(elm);
	} incontextof this,

// Start: Add: T.Imoto
	wp : function(elm)
	{
		// ム`ビ`のピリオドイベントを待つ
		return waitMoviePeriod(elm);
	} incontextof this,

	pausevideo : function(elm)
	{
		movies[+elm.slot].pause();
		return 0;
	} incontextof this,

	resumevideo : function(elm)
	{
		movies[+elm.slot].resume();
		return 0;
	} incontextof this,

	preparevideo : function(elm)
	{
		movies[+elm.slot].prepare();
		return 0;
	} incontextof this,

	rewindvideo : function(elm)
	{
		movies[+elm.slot].rewind();
		return 0;
	} incontextof this,

	videolayer : function(elm)
	{
		movies[+elm.slot].storeLayer( elm.layer, elm.page, elm.channel );
		movies[+elm.slot].setVideoLayer(getLayerFromElm(elm),elm);
		return 0;
	} incontextof this,

	clearvideolayer : function(elm)
	{
		movies[+elm.slot].cancelLayer( elm.channel );
		movies[+elm.slot].setVideoLayer(null,elm);
		return 0;
	} incontextof this,

	videosegloop : function(elm)
	{
		movies[+elm.slot].setSegment(elm);
		return 0;
	} incontextof this,

	cancelvideosegloop : function(elm)
	{
		movies[+elm.slot].cancelSegmentLoop();
		return 0;
	} incontextof this,

	videoevent : function(elm)
	{
		movies[+elm.slot].setPeriod(elm);
		return 0;
	} incontextof this,

	cancelvideoevent : function(elm)
	{
		movies[+elm.slot].cancelPeriodEvent();
		return 0;
	} incontextof this,
// End: Add: T.Imoto

	//--------------------------------------- タグハンドラ群(涫?TJS 操作) --

	eval : function(elm)
	{
		// 式のu
		Scripts.eval(elm.exp);
		return 0;
	} incontextof this,

	trace : function(elm)
	{
		// 式のトレ`ス表示
		var exp = elm.exp;
		var result = Scripts.eval(exp);
		dm("[trace] expression=\"" + exp + "\" type of result=" + typeof result + 
			" result=" + result);
		return 0;
	} incontextof this,

	input : function(elm)
	{
		// 文字列の入力
		inputString(elm);
		return 0;
	} incontextof this,

	clearsysvar : function(elm)
	{
		// システム涫のクリア
		clearSystemVariables();
		return 0;
	} incontextof this,

	clearvar : function(elm)
	{
		// ゲ`ム涫のクリア
		clearVariables();
		return 0;
	} incontextof this,

	waittrig : function(elm)
	{
		// トリガを待つ
		return waitTrigger(elm);
	} incontextof this,

	//----------------------------------------------- タグハンドラ群のKわり --

		interrupt : function(elm) { return -2; } incontextof this ];
	}
}



// TJS スクリプトはここでKわり
"
END_OF_TJS_SCRIPT
# "; /*

# assign でコピ`すべき涫の再生成を行う perl スクリプト

open FH, "MainWindow.tjs" or die;
undef($/);
$content = <FH>;

$list_store = '';
$list_restore = '';
while($content =~ /\/\*C\*\/var\s+(\w+)/gs)
{
	$list_store .= "\t\tf.$1 = $1;\n";
	$list_restore .= "\t\t$1 = f.$1 if f.$1 !== void;\n";
}

$content =~
s/\t\t\/\/ \[start_store_vars\]\n.*?\t\t\/\/ \[end_store_vars\]/\t\t\/\/ \[start_store_vars\]\n$list_store\t\t\/\/ \[end_store_vars\]/s;
$content =~
s/\t\t\/\/ \[start_restore_vars\]\n.*?\t\t\/\/ \[end_restore_vars\]/\t\t\/\/ \[start_restore_vars\]\n$list_restore\t\t\/\/ \[end_restore_vars\]/s;

open FH, ">MainWindow.tjs" or die;
print FH $content;


# */

